/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.tensorflow.ops.gen

import wumo.sim.tensorflow.buildOpTensor
import wumo.sim.tensorflow.buildOpTensors
import wumo.sim.tensorflow.ops.Output

interface gen_linalg_ops {
  fun batchCholesky(input: Output, name: String = "BatchCholesky") = run {
    buildOpTensor("BatchCholesky", name) {
      addInput(input, false)
    }
  }
  
  fun batchCholeskyGrad(l: Output, grad: Output, name: String = "BatchCholeskyGrad") = run {
    buildOpTensor("BatchCholeskyGrad", name) {
      addInput(l, false)
      addInput(grad, false)
    }
  }
  
  fun batchMatrixDeterminant(input: Output, name: String = "BatchMatrixDeterminant") = run {
    buildOpTensor("BatchMatrixDeterminant", name) {
      addInput(input, false)
    }
  }
  
  fun batchMatrixInverse(input: Output, adjoint: Boolean = false, name: String = "BatchMatrixInverse") = run {
    buildOpTensor("BatchMatrixInverse", name) {
      addInput(input, false)
      attr("adjoint", adjoint)
    }
  }
  
  fun batchMatrixSolve(matrix: Output, rhs: Output, adjoint: Boolean = false, name: String = "BatchMatrixSolve") = run {
    buildOpTensor("BatchMatrixSolve", name) {
      addInput(matrix, false)
      addInput(rhs, false)
      attr("adjoint", adjoint)
    }
  }
  
  fun batchMatrixSolveLs(matrix: Output, rhs: Output, l2Regularizer: Output, fast: Boolean = true, name: String = "BatchMatrixSolveLs") = run {
    buildOpTensor("BatchMatrixSolveLs", name) {
      addInput(matrix, false)
      addInput(rhs, false)
      addInput(l2Regularizer, false)
      attr("fast", fast)
    }
  }
  
  fun batchMatrixTriangularSolve(matrix: Output, rhs: Output, lower: Boolean = true, adjoint: Boolean = false, name: String = "BatchMatrixTriangularSolve") = run {
    buildOpTensor("BatchMatrixTriangularSolve", name) {
      addInput(matrix, false)
      addInput(rhs, false)
      attr("lower", lower)
      attr("adjoint", adjoint)
    }
  }
  
  fun batchSelfAdjointEig(input: Output, name: String = "BatchSelfAdjointEig") = run {
    buildOpTensor("BatchSelfAdjointEig", name) {
      addInput(input, false)
    }
  }
  
  fun batchSelfAdjointEigV2(input: Output, computeV: Boolean = true, name: String = "BatchSelfAdjointEigV2") = run {
    buildOpTensors("BatchSelfAdjointEigV2", name) {
      addInput(input, false)
      attr("compute_v", computeV)
    }
  }
  
  fun batchSvd(input: Output, computeUv: Boolean = true, fullMatrices: Boolean = false, name: String = "BatchSvd") = run {
    buildOpTensors("BatchSvd", name) {
      addInput(input, false)
      attr("compute_uv", computeUv)
      attr("full_matrices", fullMatrices)
    }
  }
  
  fun cholesky(input: Output, name: String = "Cholesky") = run {
    buildOpTensor("Cholesky", name) {
      addInput(input, false)
    }
  }
  
  fun choleskyGrad(l: Output, grad: Output, name: String = "CholeskyGrad") = run {
    buildOpTensor("CholeskyGrad", name) {
      addInput(l, false)
      addInput(grad, false)
    }
  }
  
  fun logMatrixDeterminant(input: Output, name: String = "LogMatrixDeterminant") = run {
    buildOpTensors("LogMatrixDeterminant", name) {
      addInput(input, false)
    }
  }
  
  fun matrixDeterminant(input: Output, name: String = "MatrixDeterminant") = run {
    buildOpTensor("MatrixDeterminant", name) {
      addInput(input, false)
    }
  }
  
  fun matrixExponential(input: Output, name: String = "MatrixExponential") = run {
    buildOpTensor("MatrixExponential", name) {
      addInput(input, false)
    }
  }
  
  fun matrixInverse(input: Output, adjoint: Boolean = false, name: String = "MatrixInverse") = run {
    buildOpTensor("MatrixInverse", name) {
      addInput(input, false)
      attr("adjoint", adjoint)
    }
  }
  
  fun matrixLogarithm(input: Output, name: String = "MatrixLogarithm") = run {
    buildOpTensor("MatrixLogarithm", name) {
      addInput(input, false)
    }
  }
  
  fun matrixSolve(matrix: Output, rhs: Output, adjoint: Boolean = false, name: String = "MatrixSolve") = run {
    buildOpTensor("MatrixSolve", name) {
      addInput(matrix, false)
      addInput(rhs, false)
      attr("adjoint", adjoint)
    }
  }
  
  fun matrixSolveLs(matrix: Output, rhs: Output, l2Regularizer: Output, fast: Boolean = true, name: String = "MatrixSolveLs") = run {
    buildOpTensor("MatrixSolveLs", name) {
      addInput(matrix, false)
      addInput(rhs, false)
      addInput(l2Regularizer, false)
      attr("fast", fast)
    }
  }
  
  fun matrixTriangularSolve(matrix: Output, rhs: Output, lower: Boolean = true, adjoint: Boolean = false, name: String = "MatrixTriangularSolve") = run {
    buildOpTensor("MatrixTriangularSolve", name) {
      addInput(matrix, false)
      addInput(rhs, false)
      attr("lower", lower)
      attr("adjoint", adjoint)
    }
  }
  
  fun qr(input: Output, fullMatrices: Boolean = false, name: String = "Qr") = run {
    buildOpTensors("Qr", name) {
      addInput(input, false)
      attr("full_matrices", fullMatrices)
    }
  }
  
  fun selfAdjointEig(input: Output, name: String = "SelfAdjointEig") = run {
    buildOpTensor("SelfAdjointEig", name) {
      addInput(input, false)
    }
  }
  
  fun selfAdjointEigV2(input: Output, computeV: Boolean = true, name: String = "SelfAdjointEigV2") = run {
    buildOpTensors("SelfAdjointEigV2", name) {
      addInput(input, false)
      attr("compute_v", computeV)
    }
  }
  
  fun svd(input: Output, computeUv: Boolean = true, fullMatrices: Boolean = false, name: String = "Svd") = run {
    buildOpTensors("Svd", name) {
      addInput(input, false)
      attr("compute_uv", computeUv)
      attr("full_matrices", fullMatrices)
    }
  }
}