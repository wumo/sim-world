/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.tensorflow.ops.gen

import wumo.sim.tensorflow.buildOpTensor
import wumo.sim.tensorflow.buildOpTensors
import wumo.sim.tensorflow.ops.Output
import wumo.sim.tensorflow.types.DataType
import wumo.sim.tensorflow.types.INT64
import wumo.sim.tensorflow.types.QINT32
import wumo.sim.tensorflow.types.QUINT8

interface gen_nn_ops {
  fun avgPool(value: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "AvgPool") = run {
    buildOpTensor("AvgPool", name) {
      addInput(value, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun avgPool3D(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "AvgPool3D") = run {
    buildOpTensor("AvgPool3D", name) {
      addInput(input, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun avgPool3DGrad(orig_input_shape: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "AvgPool3DGrad") = run {
    buildOpTensor("AvgPool3DGrad", name) {
      addInput(orig_input_shape, false)
      addInput(grad, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun biasAdd(value: Output, bias: Output, data_format: String = "NHWC", name: String = "BiasAdd") = run {
    buildOpTensor("BiasAdd", name) {
      addInput(value, false)
      addInput(bias, false)
      attr("data_format", data_format)
    }
  }
  
  fun biasAddGrad(out_backprop: Output, data_format: String = "NHWC", name: String = "BiasAddGrad") = run {
    buildOpTensor("BiasAddGrad", name) {
      addInput(out_backprop, false)
      attr("data_format", data_format)
    }
  }
  
  fun conv2D(input: Output, filter: Output, strides: Array<Long>, padding: String, use_cudnn_on_gpu: Boolean = true, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "Conv2D") = run {
    buildOpTensor("Conv2D", name) {
      addInput(input, false)
      addInput(filter, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun conv2DBackpropFilter(input: Output, filter_sizes: Output, out_backprop: Output, strides: Array<Long>, padding: String, use_cudnn_on_gpu: Boolean = true, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "Conv2DBackpropFilter") = run {
    buildOpTensor("Conv2DBackpropFilter", name) {
      addInput(input, false)
      addInput(filter_sizes, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun conv2DBackpropInput(input_sizes: Output, filter: Output, out_backprop: Output, strides: Array<Long>, padding: String, use_cudnn_on_gpu: Boolean = true, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "Conv2DBackpropInput") = run {
    buildOpTensor("Conv2DBackpropInput", name) {
      addInput(input_sizes, false)
      addInput(filter, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun conv3D(input: Output, filter: Output, strides: Array<Long>, padding: String, data_format: String = "NDHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L, 1L), name: String = "Conv3D") = run {
    buildOpTensor("Conv3D", name) {
      addInput(input, false)
      addInput(filter, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun conv3DBackpropFilterV2(input: Output, filter_sizes: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NDHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L, 1L), name: String = "Conv3DBackpropFilterV2") = run {
    buildOpTensor("Conv3DBackpropFilterV2", name) {
      addInput(input, false)
      addInput(filter_sizes, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun conv3DBackpropInputV2(input_sizes: Output, filter: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NDHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L, 1L), name: String = "Conv3DBackpropInputV2") = run {
    buildOpTensor("Conv3DBackpropInputV2", name) {
      addInput(input_sizes, false)
      addInput(filter, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun dataFormatDimMap(x: Output, src_format: String = "NHWC", dst_format: String = "NCHW", name: String = "DataFormatDimMap") = run {
    buildOpTensor("DataFormatDimMap", name) {
      addInput(x, false)
      attr("src_format", src_format)
      attr("dst_format", dst_format)
    }
  }
  
  fun dataFormatVecPermute(x: Output, src_format: String = "NHWC", dst_format: String = "NCHW", name: String = "DataFormatVecPermute") = run {
    buildOpTensor("DataFormatVecPermute", name) {
      addInput(x, false)
      attr("src_format", src_format)
      attr("dst_format", dst_format)
    }
  }
  
  fun depthwiseConv2dNative(input: Output, filter: Output, strides: Array<Long>, padding: String, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "DepthwiseConv2dNative") = run {
    buildOpTensor("DepthwiseConv2dNative", name) {
      addInput(input, false)
      addInput(filter, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun depthwiseConv2dNativeBackpropFilter(input: Output, filter_sizes: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "DepthwiseConv2dNativeBackpropFilter") = run {
    buildOpTensor("DepthwiseConv2dNativeBackpropFilter", name) {
      addInput(input, false)
      addInput(filter_sizes, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun depthwiseConv2dNativeBackpropInput(input_sizes: Output, filter: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "DepthwiseConv2dNativeBackpropInput") = run {
    buildOpTensor("DepthwiseConv2dNativeBackpropInput", name) {
      addInput(input_sizes, false)
      addInput(filter, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
      attr("dilations", dilations)
    }
  }
  
  fun dilation2D(input: Output, filter: Output, strides: Array<Long>, rates: Array<Long>, padding: String, name: String = "Dilation2D") = run {
    buildOpTensor("Dilation2D", name) {
      addInput(input, false)
      addInput(filter, false)
      attr("strides", strides)
      attr("rates", rates)
      attr("padding", padding)
    }
  }
  
  fun dilation2DBackpropFilter(input: Output, filter: Output, out_backprop: Output, strides: Array<Long>, rates: Array<Long>, padding: String, name: String = "Dilation2DBackpropFilter") = run {
    buildOpTensor("Dilation2DBackpropFilter", name) {
      addInput(input, false)
      addInput(filter, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("rates", rates)
      attr("padding", padding)
    }
  }
  
  fun dilation2DBackpropInput(input: Output, filter: Output, out_backprop: Output, strides: Array<Long>, rates: Array<Long>, padding: String, name: String = "Dilation2DBackpropInput") = run {
    buildOpTensor("Dilation2DBackpropInput", name) {
      addInput(input, false)
      addInput(filter, false)
      addInput(out_backprop, false)
      attr("strides", strides)
      attr("rates", rates)
      attr("padding", padding)
    }
  }
  
  fun elu(features: Output, name: String = "Elu") = run {
    buildOpTensor("Elu", name) {
      addInput(features, false)
    }
  }
  
  fun fractionalAvgPool(value: Output, pooling_ratio: Array<Float>, pseudo_random: Boolean = false, overlapping: Boolean = false, deterministic: Boolean = false, seed: Long = 0L, seed2: Long = 0L, name: String = "FractionalAvgPool") = run {
    buildOpTensors("FractionalAvgPool", name) {
      addInput(value, false)
      attr("pooling_ratio", pooling_ratio)
      attr("pseudo_random", pseudo_random)
      attr("overlapping", overlapping)
      attr("deterministic", deterministic)
      attr("seed", seed)
      attr("seed2", seed2)
    }
  }
  
  fun fractionalMaxPool(value: Output, pooling_ratio: Array<Float>, pseudo_random: Boolean = false, overlapping: Boolean = false, deterministic: Boolean = false, seed: Long = 0L, seed2: Long = 0L, name: String = "FractionalMaxPool") = run {
    buildOpTensors("FractionalMaxPool", name) {
      addInput(value, false)
      attr("pooling_ratio", pooling_ratio)
      attr("pseudo_random", pseudo_random)
      attr("overlapping", overlapping)
      attr("deterministic", deterministic)
      attr("seed", seed)
      attr("seed2", seed2)
    }
  }
  
  fun fusedBatchNorm(x: Output, scale: Output, offset: Output, mean: Output, variance: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNorm") = run {
    buildOpTensors("FusedBatchNorm", name) {
      addInput(x, false)
      addInput(scale, false)
      addInput(offset, false)
      addInput(mean, false)
      addInput(variance, false)
      attr("epsilon", epsilon)
      attr("data_format", data_format)
      attr("is_training", is_training)
    }
  }
  
  fun fusedBatchNormGrad(y_backprop: Output, x: Output, scale: Output, reserve_space_1: Output, reserve_space_2: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNormGrad") = run {
    buildOpTensors("FusedBatchNormGrad", name) {
      addInput(y_backprop, false)
      addInput(x, false)
      addInput(scale, false)
      addInput(reserve_space_1, false)
      addInput(reserve_space_2, false)
      attr("epsilon", epsilon)
      attr("data_format", data_format)
      attr("is_training", is_training)
    }
  }
  
  fun fusedBatchNormGradV2(y_backprop: Output, x: Output, scale: Output, reserve_space_1: Output, reserve_space_2: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNormGradV2") = run {
    buildOpTensors("FusedBatchNormGradV2", name) {
      addInput(y_backprop, false)
      addInput(x, false)
      addInput(scale, false)
      addInput(reserve_space_1, false)
      addInput(reserve_space_2, false)
      attr("epsilon", epsilon)
      attr("data_format", data_format)
      attr("is_training", is_training)
    }
  }
  
  fun fusedBatchNormV2(x: Output, scale: Output, offset: Output, mean: Output, variance: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNormV2") = run {
    buildOpTensors("FusedBatchNormV2", name) {
      addInput(x, false)
      addInput(scale, false)
      addInput(offset, false)
      addInput(mean, false)
      addInput(variance, false)
      attr("epsilon", epsilon)
      attr("data_format", data_format)
      attr("is_training", is_training)
    }
  }
  
  fun fusedPadConv2D(input: Output, paddings: Output, filter: Output, mode: String, strides: Array<Long>, padding: String, name: String = "FusedPadConv2D") = run {
    buildOpTensor("FusedPadConv2D", name) {
      addInput(input, false)
      addInput(paddings, false)
      addInput(filter, false)
      attr("mode", mode)
      attr("strides", strides)
      attr("padding", padding)
    }
  }
  
  fun fusedResizeAndPadConv2D(input: Output, size: Output, paddings: Output, filter: Output, mode: String, strides: Array<Long>, padding: String, resize_align_corners: Boolean = false, name: String = "FusedResizeAndPadConv2D") = run {
    buildOpTensor("FusedResizeAndPadConv2D", name) {
      addInput(input, false)
      addInput(size, false)
      addInput(paddings, false)
      addInput(filter, false)
      attr("mode", mode)
      attr("strides", strides)
      attr("padding", padding)
      attr("resize_align_corners", resize_align_corners)
    }
  }
  
  fun inTopK(predictions: Output, targets: Output, k: Long, name: String = "InTopK") = run {
    buildOpTensor("InTopK", name) {
      addInput(predictions, false)
      addInput(targets, false)
      attr("k", k)
    }
  }
  
  fun inTopKV2(predictions: Output, targets: Output, k: Output, name: String = "InTopKV2") = run {
    buildOpTensor("InTopKV2", name) {
      addInput(predictions, false)
      addInput(targets, false)
      addInput(k, false)
    }
  }
  
  fun l2Loss(t: Output, name: String = "L2Loss") = run {
    buildOpTensor("L2Loss", name) {
      addInput(t, false)
    }
  }
  
  fun lRN(input: Output, depth_radius: Long = 5L, bias: Float = 1.0f, alpha: Float = 1.0f, beta: Float = 0.5f, name: String = "LRN") = run {
    buildOpTensor("LRN", name) {
      addInput(input, false)
      attr("depth_radius", depth_radius)
      attr("bias", bias)
      attr("alpha", alpha)
      attr("beta", beta)
    }
  }
  
  fun logSoftmax(logits: Output, name: String = "LogSoftmax") = run {
    buildOpTensor("LogSoftmax", name) {
      addInput(logits, false)
    }
  }
  
  fun maxPool(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "MaxPool") = run {
    buildOpTensor("MaxPool", name) {
      addInput(input, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPool3D(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "MaxPool3D") = run {
    buildOpTensor("MaxPool3D", name) {
      addInput(input, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPool3DGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "MaxPool3DGrad") = run {
    buildOpTensor("MaxPool3DGrad", name) {
      addInput(orig_input, false)
      addInput(orig_output, false)
      addInput(grad, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPool3DGradGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "MaxPool3DGradGrad") = run {
    buildOpTensor("MaxPool3DGradGrad", name) {
      addInput(orig_input, false)
      addInput(orig_output, false)
      addInput(grad, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPoolGradGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGradGrad") = run {
    buildOpTensor("MaxPoolGradGrad", name) {
      addInput(orig_input, false)
      addInput(orig_output, false)
      addInput(grad, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPoolGradGradV2(orig_input: Output, orig_output: Output, grad: Output, ksize: Output, strides: Output, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGradGradV2") = run {
    buildOpTensor("MaxPoolGradGradV2", name) {
      addInput(orig_input, false)
      addInput(orig_output, false)
      addInput(grad, false)
      addInput(ksize, false)
      addInput(strides, false)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPoolGradGradWithArgmax(input: Output, grad: Output, argmax: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "MaxPoolGradGradWithArgmax") = run {
    buildOpTensor("MaxPoolGradGradWithArgmax", name) {
      addInput(input, false)
      addInput(grad, false)
      addInput(argmax, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
    }
  }
  
  fun maxPoolGradV2(orig_input: Output, orig_output: Output, grad: Output, ksize: Output, strides: Output, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGradV2") = run {
    buildOpTensor("MaxPoolGradV2", name) {
      addInput(orig_input, false)
      addInput(orig_output, false)
      addInput(grad, false)
      addInput(ksize, false)
      addInput(strides, false)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPoolV2(input: Output, ksize: Output, strides: Output, padding: String, data_format: String = "NHWC", name: String = "MaxPoolV2") = run {
    buildOpTensor("MaxPoolV2", name) {
      addInput(input, false)
      addInput(ksize, false)
      addInput(strides, false)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPoolWithArgmax(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, targmax: DataType<*> = INT64, name: String = "MaxPoolWithArgmax") = run {
    buildOpTensors("MaxPoolWithArgmax", name) {
      addInput(input, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("Targmax", targmax)
    }
  }
  
  fun nthElement(input: Output, n: Output, reverse: Boolean = false, name: String = "NthElement") = run {
    buildOpTensor("NthElement", name) {
      addInput(input, false)
      addInput(n, false)
      attr("reverse", reverse)
    }
  }
  
  fun quantizedAvgPool(input: Output, min_input: Output, max_input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "QuantizedAvgPool") = run {
    buildOpTensors("QuantizedAvgPool", name) {
      addInput(input, false)
      addInput(min_input, false)
      addInput(max_input, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
    }
  }
  
  fun quantizedBatchNormWithGlobalNormalization(t: Output, t_min: Output, t_max: Output, m: Output, m_min: Output, m_max: Output, v: Output, v_min: Output, v_max: Output, beta: Output, beta_min: Output, beta_max: Output, gamma: Output, gamma_min: Output, gamma_max: Output, out_type: DataType<*>, variance_epsilon: Float, scale_after_normalization: Boolean, name: String = "QuantizedBatchNormWithGlobalNormalization") = run {
    buildOpTensors("QuantizedBatchNormWithGlobalNormalization", name) {
      addInput(t, false)
      addInput(t_min, false)
      addInput(t_max, false)
      addInput(m, false)
      addInput(m_min, false)
      addInput(m_max, false)
      addInput(v, false)
      addInput(v_min, false)
      addInput(v_max, false)
      addInput(beta, false)
      addInput(beta_min, false)
      addInput(beta_max, false)
      addInput(gamma, false)
      addInput(gamma_min, false)
      addInput(gamma_max, false)
      attr("out_type", out_type)
      attr("variance_epsilon", variance_epsilon)
      attr("scale_after_normalization", scale_after_normalization)
    }
  }
  
  fun quantizedBiasAdd(input: Output, bias: Output, min_input: Output, max_input: Output, min_bias: Output, max_bias: Output, out_type: DataType<*>, name: String = "QuantizedBiasAdd") = run {
    buildOpTensors("QuantizedBiasAdd", name) {
      addInput(input, false)
      addInput(bias, false)
      addInput(min_input, false)
      addInput(max_input, false)
      addInput(min_bias, false)
      addInput(max_bias, false)
      attr("out_type", out_type)
    }
  }
  
  fun quantizedConv2D(input: Output, filter: Output, min_input: Output, max_input: Output, min_filter: Output, max_filter: Output, strides: Array<Long>, padding: String, out_type: DataType<*> = QINT32, dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "QuantizedConv2D") = run {
    buildOpTensors("QuantizedConv2D", name) {
      addInput(input, false)
      addInput(filter, false)
      addInput(min_input, false)
      addInput(max_input, false)
      addInput(min_filter, false)
      addInput(max_filter, false)
      attr("strides", strides)
      attr("padding", padding)
      attr("out_type", out_type)
      attr("dilations", dilations)
    }
  }
  
  fun quantizedMaxPool(input: Output, min_input: Output, max_input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "QuantizedMaxPool") = run {
    buildOpTensors("QuantizedMaxPool", name) {
      addInput(input, false)
      addInput(min_input, false)
      addInput(max_input, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
    }
  }
  
  fun quantizedRelu(features: Output, min_features: Output, max_features: Output, out_type: DataType<*> = QUINT8, name: String = "QuantizedRelu") = run {
    buildOpTensors("QuantizedRelu", name) {
      addInput(features, false)
      addInput(min_features, false)
      addInput(max_features, false)
      attr("out_type", out_type)
    }
  }
  
  fun quantizedRelu6(features: Output, min_features: Output, max_features: Output, out_type: DataType<*> = QUINT8, name: String = "QuantizedRelu6") = run {
    buildOpTensors("QuantizedRelu6", name) {
      addInput(features, false)
      addInput(min_features, false)
      addInput(max_features, false)
      attr("out_type", out_type)
    }
  }
  
  fun quantizedReluX(features: Output, max_value: Output, min_features: Output, max_features: Output, out_type: DataType<*> = QUINT8, name: String = "QuantizedReluX") = run {
    buildOpTensors("QuantizedReluX", name) {
      addInput(features, false)
      addInput(max_value, false)
      addInput(min_features, false)
      addInput(max_features, false)
      attr("out_type", out_type)
    }
  }
  
  fun relu(features: Output, name: String = "Relu") = run {
    buildOpTensor("Relu", name) {
      addInput(features, false)
    }
  }
  
  fun relu6(features: Output, name: String = "Relu6") = run {
    buildOpTensor("Relu6", name) {
      addInput(features, false)
    }
  }
  
  fun selu(features: Output, name: String = "Selu") = run {
    buildOpTensor("Selu", name) {
      addInput(features, false)
    }
  }
  
  fun softmax(logits: Output, name: String = "Softmax") = run {
    buildOpTensor("Softmax", name) {
      addInput(logits, false)
    }
  }
  
  fun softmaxCrossEntropyWithLogits(features: Output, labels: Output, name: String = "SoftmaxCrossEntropyWithLogits") = run {
    buildOpTensors("SoftmaxCrossEntropyWithLogits", name) {
      addInput(features, false)
      addInput(labels, false)
    }
  }
  
  fun softplus(features: Output, name: String = "Softplus") = run {
    buildOpTensor("Softplus", name) {
      addInput(features, false)
    }
  }
  
  fun softsign(features: Output, name: String = "Softsign") = run {
    buildOpTensor("Softsign", name) {
      addInput(features, false)
    }
  }
  
  fun sparseSoftmaxCrossEntropyWithLogits(features: Output, labels: Output, name: String = "SparseSoftmaxCrossEntropyWithLogits") = run {
    buildOpTensors("SparseSoftmaxCrossEntropyWithLogits", name) {
      addInput(features, false)
      addInput(labels, false)
    }
  }
  
  fun topKV2(input: Output, k: Output, sorted: Boolean = true, name: String = "TopKV2") = run {
    buildOpTensors("TopKV2", name) {
      addInput(input, false)
      addInput(k, false)
      attr("sorted", sorted)
    }
  }
  
  fun avgPoolGrad(orig_input_shape: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "AvgPoolGrad") = run {
    buildOpTensor("AvgPoolGrad", name) {
      addInput(orig_input_shape, false)
      addInput(grad, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun eluGrad(gradients: Output, outputs: Output, name: String = "EluGrad") = run {
    buildOpTensor("EluGrad", name) {
      addInput(gradients, false)
      addInput(outputs, false)
    }
  }
  
  fun fractionalAvgPoolGrad(orig_input_tensor_shape: Output, out_backprop: Output, row_pooling_sequence: Output, col_pooling_sequence: Output, overlapping: Boolean = false, name: String = "FractionalAvgPoolGrad") = run {
    buildOpTensor("FractionalAvgPoolGrad", name) {
      addInput(orig_input_tensor_shape, false)
      addInput(out_backprop, false)
      addInput(row_pooling_sequence, false)
      addInput(col_pooling_sequence, false)
      attr("overlapping", overlapping)
    }
  }
  
  fun fractionalMaxPoolGrad(orig_input: Output, orig_output: Output, out_backprop: Output, row_pooling_sequence: Output, col_pooling_sequence: Output, overlapping: Boolean = false, name: String = "FractionalMaxPoolGrad") = run {
    buildOpTensor("FractionalMaxPoolGrad", name) {
      addInput(orig_input, false)
      addInput(orig_output, false)
      addInput(out_backprop, false)
      addInput(row_pooling_sequence, false)
      addInput(col_pooling_sequence, false)
      attr("overlapping", overlapping)
    }
  }
  
  fun lRNGrad(input_grads: Output, input_image: Output, output_image: Output, depth_radius: Long = 5L, bias: Float = 1.0f, alpha: Float = 1.0f, beta: Float = 0.5f, name: String = "LRNGrad") = run {
    buildOpTensor("LRNGrad", name) {
      addInput(input_grads, false)
      addInput(input_image, false)
      addInput(output_image, false)
      attr("depth_radius", depth_radius)
      attr("bias", bias)
      attr("alpha", alpha)
      attr("beta", beta)
    }
  }
  
  fun maxPoolGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGrad") = run {
    buildOpTensor("MaxPoolGrad", name) {
      addInput(orig_input, false)
      addInput(orig_output, false)
      addInput(grad, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
      attr("data_format", data_format)
    }
  }
  
  fun maxPoolGradWithArgmax(input: Output, grad: Output, argmax: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "MaxPoolGradWithArgmax") = run {
    buildOpTensor("MaxPoolGradWithArgmax", name) {
      addInput(input, false)
      addInput(grad, false)
      addInput(argmax, false)
      attr("ksize", ksize)
      attr("strides", strides)
      attr("padding", padding)
    }
  }
  
  fun relu6Grad(gradients: Output, features: Output, name: String = "Relu6Grad") = run {
    buildOpTensor("Relu6Grad", name) {
      addInput(gradients, false)
      addInput(features, false)
    }
  }
  
  fun reluGrad(gradients: Output, features: Output, name: String = "ReluGrad") = run {
    buildOpTensor("ReluGrad", name) {
      addInput(gradients, false)
      addInput(features, false)
    }
  }
  
  fun seluGrad(gradients: Output, outputs: Output, name: String = "SeluGrad") = run {
    buildOpTensor("SeluGrad", name) {
      addInput(gradients, false)
      addInput(outputs, false)
    }
  }
  
  fun softplusGrad(gradients: Output, features: Output, name: String = "SoftplusGrad") = run {
    buildOpTensor("SoftplusGrad", name) {
      addInput(gradients, false)
      addInput(features, false)
    }
  }
  
  fun softsignGrad(gradients: Output, features: Output, name: String = "SoftsignGrad") = run {
    buildOpTensor("SoftsignGrad", name) {
      addInput(gradients, false)
      addInput(features, false)
    }
  }
}