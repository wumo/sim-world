/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.tensorflow.ops.gen

import org.bytedeco.javacpp.tensorflow.*
import wumo.sim.algorithm.tensorflow.TF
import wumo.sim.algorithm.tensorflow.ops.Output
import wumo.sim.algorithm.tensorflow.buildOpTensor
import wumo.sim.algorithm.tensorflow.buildOpTensors

fun TF.avgPool(value: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "AvgPool") = run {
  buildOpTensor("AvgPool", name) {
    addInput(value, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.avgPool3D(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "AvgPool3D") = run {
  buildOpTensor("AvgPool3D", name) {
    addInput(input, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.avgPool3DGrad(orig_input_shape: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "AvgPool3DGrad") = run {
  buildOpTensor("AvgPool3DGrad", name) {
    addInput(orig_input_shape, false)
    addInput(grad, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.biasAdd(value: Output, bias: Output, data_format: String = "NHWC", name: String = "BiasAdd") = run {
  buildOpTensor("BiasAdd", name) {
    addInput(value, false)
    addInput(bias, false)
    attr("data_format", data_format)
  }
}

fun TF.biasAddGrad(out_backprop: Output, data_format: String = "NHWC", name: String = "BiasAddGrad") = run {
  buildOpTensor("BiasAddGrad", name) {
    addInput(out_backprop, false)
    attr("data_format", data_format)
  }
}

fun TF.conv2D(input: Output, filter: Output, strides: Array<Long>, padding: String, use_cudnn_on_gpu: Boolean = true, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "Conv2D") = run {
  buildOpTensor("Conv2D", name) {
    addInput(input, false)
    addInput(filter, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.conv2DBackpropFilter(input: Output, filter_sizes: Output, out_backprop: Output, strides: Array<Long>, padding: String, use_cudnn_on_gpu: Boolean = true, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "Conv2DBackpropFilter") = run {
  buildOpTensor("Conv2DBackpropFilter", name) {
    addInput(input, false)
    addInput(filter_sizes, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.conv2DBackpropInput(input_sizes: Output, filter: Output, out_backprop: Output, strides: Array<Long>, padding: String, use_cudnn_on_gpu: Boolean = true, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "Conv2DBackpropInput") = run {
  buildOpTensor("Conv2DBackpropInput", name) {
    addInput(input_sizes, false)
    addInput(filter, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("use_cudnn_on_gpu", use_cudnn_on_gpu)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.conv3D(input: Output, filter: Output, strides: Array<Long>, padding: String, data_format: String = "NDHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L, 1L), name: String = "Conv3D") = run {
  buildOpTensor("Conv3D", name) {
    addInput(input, false)
    addInput(filter, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.conv3DBackpropFilterV2(input: Output, filter_sizes: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NDHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L, 1L), name: String = "Conv3DBackpropFilterV2") = run {
  buildOpTensor("Conv3DBackpropFilterV2", name) {
    addInput(input, false)
    addInput(filter_sizes, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.conv3DBackpropInputV2(input_sizes: Output, filter: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NDHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L, 1L), name: String = "Conv3DBackpropInputV2") = run {
  buildOpTensor("Conv3DBackpropInputV2", name) {
    addInput(input_sizes, false)
    addInput(filter, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.dataFormatDimMap(x: Output, src_format: String = "NHWC", dst_format: String = "NCHW", name: String = "DataFormatDimMap") = run {
  buildOpTensor("DataFormatDimMap", name) {
    addInput(x, false)
    attr("src_format", src_format)
    attr("dst_format", dst_format)
  }
}

fun TF.dataFormatVecPermute(x: Output, src_format: String = "NHWC", dst_format: String = "NCHW", name: String = "DataFormatVecPermute") = run {
  buildOpTensor("DataFormatVecPermute", name) {
    addInput(x, false)
    attr("src_format", src_format)
    attr("dst_format", dst_format)
  }
}

fun TF.depthwiseConv2dNative(input: Output, filter: Output, strides: Array<Long>, padding: String, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "DepthwiseConv2dNative") = run {
  buildOpTensor("DepthwiseConv2dNative", name) {
    addInput(input, false)
    addInput(filter, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.depthwiseConv2dNativeBackpropFilter(input: Output, filter_sizes: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "DepthwiseConv2dNativeBackpropFilter") = run {
  buildOpTensor("DepthwiseConv2dNativeBackpropFilter", name) {
    addInput(input, false)
    addInput(filter_sizes, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.depthwiseConv2dNativeBackpropInput(input_sizes: Output, filter: Output, out_backprop: Output, strides: Array<Long>, padding: String, data_format: String = "NHWC", dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "DepthwiseConv2dNativeBackpropInput") = run {
  buildOpTensor("DepthwiseConv2dNativeBackpropInput", name) {
    addInput(input_sizes, false)
    addInput(filter, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
    attr("dilations", dilations)
  }
}

fun TF.dilation2D(input: Output, filter: Output, strides: Array<Long>, rates: Array<Long>, padding: String, name: String = "Dilation2D") = run {
  buildOpTensor("Dilation2D", name) {
    addInput(input, false)
    addInput(filter, false)
    attr("strides", strides)
    attr("rates", rates)
    attr("padding", padding)
  }
}

fun TF.dilation2DBackpropFilter(input: Output, filter: Output, out_backprop: Output, strides: Array<Long>, rates: Array<Long>, padding: String, name: String = "Dilation2DBackpropFilter") = run {
  buildOpTensor("Dilation2DBackpropFilter", name) {
    addInput(input, false)
    addInput(filter, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("rates", rates)
    attr("padding", padding)
  }
}

fun TF.dilation2DBackpropInput(input: Output, filter: Output, out_backprop: Output, strides: Array<Long>, rates: Array<Long>, padding: String, name: String = "Dilation2DBackpropInput") = run {
  buildOpTensor("Dilation2DBackpropInput", name) {
    addInput(input, false)
    addInput(filter, false)
    addInput(out_backprop, false)
    attr("strides", strides)
    attr("rates", rates)
    attr("padding", padding)
  }
}

fun TF.elu(features: Output, name: String = "Elu") = run {
  buildOpTensor("Elu", name) {
    addInput(features, false)
  }
}

fun TF.fractionalAvgPool(value: Output, pooling_ratio: Array<Float>, pseudo_random: Boolean = false, overlapping: Boolean = false, deterministic: Boolean = false, seed: Long = 0L, seed2: Long = 0L, name: String = "FractionalAvgPool") = run {
  buildOpTensors("FractionalAvgPool", name) {
    addInput(value, false)
    attr("pooling_ratio", pooling_ratio)
    attr("pseudo_random", pseudo_random)
    attr("overlapping", overlapping)
    attr("deterministic", deterministic)
    attr("seed", seed)
    attr("seed2", seed2)
  }
}

fun TF.fractionalMaxPool(value: Output, pooling_ratio: Array<Float>, pseudo_random: Boolean = false, overlapping: Boolean = false, deterministic: Boolean = false, seed: Long = 0L, seed2: Long = 0L, name: String = "FractionalMaxPool") = run {
  buildOpTensors("FractionalMaxPool", name) {
    addInput(value, false)
    attr("pooling_ratio", pooling_ratio)
    attr("pseudo_random", pseudo_random)
    attr("overlapping", overlapping)
    attr("deterministic", deterministic)
    attr("seed", seed)
    attr("seed2", seed2)
  }
}

fun TF.fusedBatchNorm(x: Output, scale: Output, offset: Output, mean: Output, variance: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNorm") = run {
  buildOpTensors("FusedBatchNorm", name) {
    addInput(x, false)
    addInput(scale, false)
    addInput(offset, false)
    addInput(mean, false)
    addInput(variance, false)
    attr("epsilon", epsilon)
    attr("data_format", data_format)
    attr("is_training", is_training)
  }
}

fun TF.fusedBatchNormGrad(y_backprop: Output, x: Output, scale: Output, reserve_space_1: Output, reserve_space_2: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNormGrad") = run {
  buildOpTensors("FusedBatchNormGrad", name) {
    addInput(y_backprop, false)
    addInput(x, false)
    addInput(scale, false)
    addInput(reserve_space_1, false)
    addInput(reserve_space_2, false)
    attr("epsilon", epsilon)
    attr("data_format", data_format)
    attr("is_training", is_training)
  }
}

fun TF.fusedBatchNormGradV2(y_backprop: Output, x: Output, scale: Output, reserve_space_1: Output, reserve_space_2: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNormGradV2") = run {
  buildOpTensors("FusedBatchNormGradV2", name) {
    addInput(y_backprop, false)
    addInput(x, false)
    addInput(scale, false)
    addInput(reserve_space_1, false)
    addInput(reserve_space_2, false)
    attr("epsilon", epsilon)
    attr("data_format", data_format)
    attr("is_training", is_training)
  }
}

fun TF.fusedBatchNormV2(x: Output, scale: Output, offset: Output, mean: Output, variance: Output, epsilon: Float = 1.0E-4f, data_format: String = "NHWC", is_training: Boolean = true, name: String = "FusedBatchNormV2") = run {
  buildOpTensors("FusedBatchNormV2", name) {
    addInput(x, false)
    addInput(scale, false)
    addInput(offset, false)
    addInput(mean, false)
    addInput(variance, false)
    attr("epsilon", epsilon)
    attr("data_format", data_format)
    attr("is_training", is_training)
  }
}

fun TF.fusedPadConv2D(input: Output, paddings: Output, filter: Output, mode: String, strides: Array<Long>, padding: String, name: String = "FusedPadConv2D") = run {
  buildOpTensor("FusedPadConv2D", name) {
    addInput(input, false)
    addInput(paddings, false)
    addInput(filter, false)
    attr("mode", mode)
    attr("strides", strides)
    attr("padding", padding)
  }
}

fun TF.fusedResizeAndPadConv2D(input: Output, size: Output, paddings: Output, filter: Output, mode: String, strides: Array<Long>, padding: String, resize_align_corners: Boolean = false, name: String = "FusedResizeAndPadConv2D") = run {
  buildOpTensor("FusedResizeAndPadConv2D", name) {
    addInput(input, false)
    addInput(size, false)
    addInput(paddings, false)
    addInput(filter, false)
    attr("mode", mode)
    attr("strides", strides)
    attr("padding", padding)
    attr("resize_align_corners", resize_align_corners)
  }
}

fun TF.inTopK(predictions: Output, targets: Output, k: Long, name: String = "InTopK") = run {
  buildOpTensor("InTopK", name) {
    addInput(predictions, false)
    addInput(targets, false)
    attr("k", k)
  }
}

fun TF.inTopKV2(predictions: Output, targets: Output, k: Output, name: String = "InTopKV2") = run {
  buildOpTensor("InTopKV2", name) {
    addInput(predictions, false)
    addInput(targets, false)
    addInput(k, false)
  }
}

fun TF.l2Loss(t: Output, name: String = "L2Loss") = run {
  buildOpTensor("L2Loss", name) {
    addInput(t, false)
  }
}

fun TF.lRN(input: Output, depth_radius: Long = 5L, bias: Float = 1.0f, alpha: Float = 1.0f, beta: Float = 0.5f, name: String = "LRN") = run {
  buildOpTensor("LRN", name) {
    addInput(input, false)
    attr("depth_radius", depth_radius)
    attr("bias", bias)
    attr("alpha", alpha)
    attr("beta", beta)
  }
}

fun TF.logSoftmax(logits: Output, name: String = "LogSoftmax") = run {
  buildOpTensor("LogSoftmax", name) {
    addInput(logits, false)
  }
}

fun TF.maxPool(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "MaxPool") = run {
  buildOpTensor("MaxPool", name) {
    addInput(input, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPool3D(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "MaxPool3D") = run {
  buildOpTensor("MaxPool3D", name) {
    addInput(input, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPool3DGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "MaxPool3DGrad") = run {
  buildOpTensor("MaxPool3DGrad", name) {
    addInput(orig_input, false)
    addInput(orig_output, false)
    addInput(grad, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPool3DGradGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NDHWC", name: String = "MaxPool3DGradGrad") = run {
  buildOpTensor("MaxPool3DGradGrad", name) {
    addInput(orig_input, false)
    addInput(orig_output, false)
    addInput(grad, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPoolGradGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGradGrad") = run {
  buildOpTensor("MaxPoolGradGrad", name) {
    addInput(orig_input, false)
    addInput(orig_output, false)
    addInput(grad, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPoolGradGradV2(orig_input: Output, orig_output: Output, grad: Output, ksize: Output, strides: Output, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGradGradV2") = run {
  buildOpTensor("MaxPoolGradGradV2", name) {
    addInput(orig_input, false)
    addInput(orig_output, false)
    addInput(grad, false)
    addInput(ksize, false)
    addInput(strides, false)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPoolGradGradWithArgmax(input: Output, grad: Output, argmax: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "MaxPoolGradGradWithArgmax") = run {
  buildOpTensor("MaxPoolGradGradWithArgmax", name) {
    addInput(input, false)
    addInput(grad, false)
    addInput(argmax, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
  }
}

fun TF.maxPoolGradV2(orig_input: Output, orig_output: Output, grad: Output, ksize: Output, strides: Output, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGradV2") = run {
  buildOpTensor("MaxPoolGradV2", name) {
    addInput(orig_input, false)
    addInput(orig_output, false)
    addInput(grad, false)
    addInput(ksize, false)
    addInput(strides, false)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPoolV2(input: Output, ksize: Output, strides: Output, padding: String, data_format: String = "NHWC", name: String = "MaxPoolV2") = run {
  buildOpTensor("MaxPoolV2", name) {
    addInput(input, false)
    addInput(ksize, false)
    addInput(strides, false)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPoolWithArgmax(input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, targmax: Int = DT_INT64, name: String = "MaxPoolWithArgmax") = run {
  buildOpTensors("MaxPoolWithArgmax", name) {
    addInput(input, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attrType("Targmax", targmax)
  }
}

fun TF.nthElement(input: Output, n: Output, reverse: Boolean = false, name: String = "NthElement") = run {
  buildOpTensor("NthElement", name) {
    addInput(input, false)
    addInput(n, false)
    attr("reverse", reverse)
  }
}

fun TF.quantizedAvgPool(input: Output, min_input: Output, max_input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "QuantizedAvgPool") = run {
  buildOpTensors("QuantizedAvgPool", name) {
    addInput(input, false)
    addInput(min_input, false)
    addInput(max_input, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
  }
}

fun TF.quantizedBatchNormWithGlobalNormalization(t: Output, t_min: Output, t_max: Output, m: Output, m_min: Output, m_max: Output, v: Output, v_min: Output, v_max: Output, beta: Output, beta_min: Output, beta_max: Output, gamma: Output, gamma_min: Output, gamma_max: Output, out_type: Int, variance_epsilon: Float, scale_after_normalization: Boolean, name: String = "QuantizedBatchNormWithGlobalNormalization") = run {
  buildOpTensors("QuantizedBatchNormWithGlobalNormalization", name) {
    addInput(t, false)
    addInput(t_min, false)
    addInput(t_max, false)
    addInput(m, false)
    addInput(m_min, false)
    addInput(m_max, false)
    addInput(v, false)
    addInput(v_min, false)
    addInput(v_max, false)
    addInput(beta, false)
    addInput(beta_min, false)
    addInput(beta_max, false)
    addInput(gamma, false)
    addInput(gamma_min, false)
    addInput(gamma_max, false)
    attrType("out_type", out_type)
    attr("variance_epsilon", variance_epsilon)
    attr("scale_after_normalization", scale_after_normalization)
  }
}

fun TF.quantizedBiasAdd(input: Output, bias: Output, min_input: Output, max_input: Output, min_bias: Output, max_bias: Output, out_type: Int, name: String = "QuantizedBiasAdd") = run {
  buildOpTensors("QuantizedBiasAdd", name) {
    addInput(input, false)
    addInput(bias, false)
    addInput(min_input, false)
    addInput(max_input, false)
    addInput(min_bias, false)
    addInput(max_bias, false)
    attrType("out_type", out_type)
  }
}

fun TF.quantizedConv2D(input: Output, filter: Output, min_input: Output, max_input: Output, min_filter: Output, max_filter: Output, strides: Array<Long>, padding: String, out_type: Int = DT_QINT32, dilations: Array<Long> = arrayOf(1L, 1L, 1L, 1L), name: String = "QuantizedConv2D") = run {
  buildOpTensors("QuantizedConv2D", name) {
    addInput(input, false)
    addInput(filter, false)
    addInput(min_input, false)
    addInput(max_input, false)
    addInput(min_filter, false)
    addInput(max_filter, false)
    attr("strides", strides)
    attr("padding", padding)
    attrType("out_type", out_type)
    attr("dilations", dilations)
  }
}

fun TF.quantizedMaxPool(input: Output, min_input: Output, max_input: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "QuantizedMaxPool") = run {
  buildOpTensors("QuantizedMaxPool", name) {
    addInput(input, false)
    addInput(min_input, false)
    addInput(max_input, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
  }
}

fun TF.quantizedRelu(features: Output, min_features: Output, max_features: Output, out_type: Int = DT_QUINT8, name: String = "QuantizedRelu") = run {
  buildOpTensors("QuantizedRelu", name) {
    addInput(features, false)
    addInput(min_features, false)
    addInput(max_features, false)
    attrType("out_type", out_type)
  }
}

fun TF.quantizedRelu6(features: Output, min_features: Output, max_features: Output, out_type: Int = DT_QUINT8, name: String = "QuantizedRelu6") = run {
  buildOpTensors("QuantizedRelu6", name) {
    addInput(features, false)
    addInput(min_features, false)
    addInput(max_features, false)
    attrType("out_type", out_type)
  }
}

fun TF.quantizedReluX(features: Output, max_value: Output, min_features: Output, max_features: Output, out_type: Int = DT_QUINT8, name: String = "QuantizedReluX") = run {
  buildOpTensors("QuantizedReluX", name) {
    addInput(features, false)
    addInput(max_value, false)
    addInput(min_features, false)
    addInput(max_features, false)
    attrType("out_type", out_type)
  }
}

fun TF.relu(features: Output, name: String = "Relu") = run {
  buildOpTensor("Relu", name) {
    addInput(features, false)
  }
}

fun TF.relu6(features: Output, name: String = "Relu6") = run {
  buildOpTensor("Relu6", name) {
    addInput(features, false)
  }
}

fun TF.selu(features: Output, name: String = "Selu") = run {
  buildOpTensor("Selu", name) {
    addInput(features, false)
  }
}

fun TF.softmax(logits: Output, name: String = "Softmax") = run {
  buildOpTensor("Softmax", name) {
    addInput(logits, false)
  }
}

fun TF.softmaxCrossEntropyWithLogits(features: Output, labels: Output, name: String = "SoftmaxCrossEntropyWithLogits") = run {
  buildOpTensors("SoftmaxCrossEntropyWithLogits", name) {
    addInput(features, false)
    addInput(labels, false)
  }
}

fun TF.softplus(features: Output, name: String = "Softplus") = run {
  buildOpTensor("Softplus", name) {
    addInput(features, false)
  }
}

fun TF.softsign(features: Output, name: String = "Softsign") = run {
  buildOpTensor("Softsign", name) {
    addInput(features, false)
  }
}

fun TF.sparseSoftmaxCrossEntropyWithLogits(features: Output, labels: Output, name: String = "SparseSoftmaxCrossEntropyWithLogits") = run {
  buildOpTensors("SparseSoftmaxCrossEntropyWithLogits", name) {
    addInput(features, false)
    addInput(labels, false)
  }
}

fun TF.topKV2(input: Output, k: Output, sorted: Boolean = true, name: String = "TopKV2") = run {
  buildOpTensors("TopKV2", name) {
    addInput(input, false)
    addInput(k, false)
    attr("sorted", sorted)
  }
}

fun TF.avgPoolGrad(orig_input_shape: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "AvgPoolGrad") = run {
  buildOpTensor("AvgPoolGrad", name) {
    addInput(orig_input_shape, false)
    addInput(grad, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.eluGrad(gradients: Output, outputs: Output, name: String = "EluGrad") = run {
  buildOpTensor("EluGrad", name) {
    addInput(gradients, false)
    addInput(outputs, false)
  }
}

fun TF.fractionalAvgPoolGrad(orig_input_tensor_shape: Output, out_backprop: Output, row_pooling_sequence: Output, col_pooling_sequence: Output, overlapping: Boolean = false, name: String = "FractionalAvgPoolGrad") = run {
  buildOpTensor("FractionalAvgPoolGrad", name) {
    addInput(orig_input_tensor_shape, false)
    addInput(out_backprop, false)
    addInput(row_pooling_sequence, false)
    addInput(col_pooling_sequence, false)
    attr("overlapping", overlapping)
  }
}

fun TF.fractionalMaxPoolGrad(orig_input: Output, orig_output: Output, out_backprop: Output, row_pooling_sequence: Output, col_pooling_sequence: Output, overlapping: Boolean = false, name: String = "FractionalMaxPoolGrad") = run {
  buildOpTensor("FractionalMaxPoolGrad", name) {
    addInput(orig_input, false)
    addInput(orig_output, false)
    addInput(out_backprop, false)
    addInput(row_pooling_sequence, false)
    addInput(col_pooling_sequence, false)
    attr("overlapping", overlapping)
  }
}

fun TF.lRNGrad(input_grads: Output, input_image: Output, output_image: Output, depth_radius: Long = 5L, bias: Float = 1.0f, alpha: Float = 1.0f, beta: Float = 0.5f, name: String = "LRNGrad") = run {
  buildOpTensor("LRNGrad", name) {
    addInput(input_grads, false)
    addInput(input_image, false)
    addInput(output_image, false)
    attr("depth_radius", depth_radius)
    attr("bias", bias)
    attr("alpha", alpha)
    attr("beta", beta)
  }
}

fun TF.maxPoolGrad(orig_input: Output, orig_output: Output, grad: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, data_format: String = "NHWC", name: String = "MaxPoolGrad") = run {
  buildOpTensor("MaxPoolGrad", name) {
    addInput(orig_input, false)
    addInput(orig_output, false)
    addInput(grad, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
    attr("data_format", data_format)
  }
}

fun TF.maxPoolGradWithArgmax(input: Output, grad: Output, argmax: Output, ksize: Array<Long>, strides: Array<Long>, padding: String, name: String = "MaxPoolGradWithArgmax") = run {
  buildOpTensor("MaxPoolGradWithArgmax", name) {
    addInput(input, false)
    addInput(grad, false)
    addInput(argmax, false)
    attr("ksize", ksize)
    attr("strides", strides)
    attr("padding", padding)
  }
}

fun TF.relu6Grad(gradients: Output, features: Output, name: String = "Relu6Grad") = run {
  buildOpTensor("Relu6Grad", name) {
    addInput(gradients, false)
    addInput(features, false)
  }
}

fun TF.reluGrad(gradients: Output, features: Output, name: String = "ReluGrad") = run {
  buildOpTensor("ReluGrad", name) {
    addInput(gradients, false)
    addInput(features, false)
  }
}

fun TF.seluGrad(gradients: Output, outputs: Output, name: String = "SeluGrad") = run {
  buildOpTensor("SeluGrad", name) {
    addInput(gradients, false)
    addInput(outputs, false)
  }
}

fun TF.softplusGrad(gradients: Output, features: Output, name: String = "SoftplusGrad") = run {
  buildOpTensor("SoftplusGrad", name) {
    addInput(gradients, false)
    addInput(features, false)
  }
}

fun TF.softsignGrad(gradients: Output, features: Output, name: String = "SoftsignGrad") = run {
  buildOpTensor("SoftsignGrad", name) {
    addInput(gradients, false)
    addInput(features, false)
  }
}
