/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.tensorflow.ops.gen

import org.bytedeco.javacpp.tensorflow.DT_INT32
import org.bytedeco.javacpp.tensorflow.DT_UINT8
import wumo.sim.tensorflow.TF
import wumo.sim.tensorflow.ops.Output
import wumo.sim.tensorflow.buildOpTensor
import wumo.sim.tensorflow.buildOpTensors

fun TF.adjustContrastv2(images: Output, contrast_factor: Output, name: String = "AdjustContrastv2") = run {
  buildOpTensor("AdjustContrastv2", name) {
    addInput(images, false)
    addInput(contrast_factor, false)
  }
}

fun TF.adjustHue(images: Output, delta: Output, name: String = "AdjustHue") = run {
  buildOpTensor("AdjustHue", name) {
    addInput(images, false)
    addInput(delta, false)
  }
}

fun TF.adjustSaturation(images: Output, scale: Output, name: String = "AdjustSaturation") = run {
  buildOpTensor("AdjustSaturation", name) {
    addInput(images, false)
    addInput(scale, false)
  }
}

fun TF.cropAndResize(image: Output, boxes: Output, box_ind: Output, crop_size: Output, method: String = "bilinear", extrapolation_value: Float = 0.0f, name: String = "CropAndResize") = run {
  buildOpTensor("CropAndResize", name) {
    addInput(image, false)
    addInput(boxes, false)
    addInput(box_ind, false)
    addInput(crop_size, false)
    attr("method", method)
    attr("extrapolation_value", extrapolation_value)
  }
}

fun TF.cropAndResizeGradBoxes(grads: Output, image: Output, boxes: Output, box_ind: Output, method: String = "bilinear", name: String = "CropAndResizeGradBoxes") = run {
  buildOpTensor("CropAndResizeGradBoxes", name) {
    addInput(grads, false)
    addInput(image, false)
    addInput(boxes, false)
    addInput(box_ind, false)
    attr("method", method)
  }
}

fun TF.cropAndResizeGradImage(grads: Output, boxes: Output, box_ind: Output, image_size: Output, t: Int, method: String = "bilinear", name: String = "CropAndResizeGradImage") = run {
  buildOpTensor("CropAndResizeGradImage", name) {
    addInput(grads, false)
    addInput(boxes, false)
    addInput(box_ind, false)
    addInput(image_size, false)
    attrType("T", t)
    attr("method", method)
  }
}

fun TF.decodeAndCropJpeg(contents: Output, crop_window: Output, channels: Long = 0L, ratio: Long = 1L, fancy_upscaling: Boolean = true, try_recover_truncated: Boolean = false, acceptable_fraction: Float = 1.0f, dct_method: String = "", name: String = "DecodeAndCropJpeg") = run {
  buildOpTensor("DecodeAndCropJpeg", name) {
    addInput(contents, false)
    addInput(crop_window, false)
    attr("channels", channels)
    attr("ratio", ratio)
    attr("fancy_upscaling", fancy_upscaling)
    attr("try_recover_truncated", try_recover_truncated)
    attr("acceptable_fraction", acceptable_fraction)
    attr("dct_method", dct_method)
  }
}

fun TF.decodeBmp(contents: Output, channels: Long = 0L, name: String = "DecodeBmp") = run {
  buildOpTensor("DecodeBmp", name) {
    addInput(contents, false)
    attr("channels", channels)
  }
}

fun TF.decodeGif(contents: Output, name: String = "DecodeGif") = run {
  buildOpTensor("DecodeGif", name) {
    addInput(contents, false)
  }
}

fun TF.decodeJpeg(contents: Output, channels: Long = 0L, ratio: Long = 1L, fancy_upscaling: Boolean = true, try_recover_truncated: Boolean = false, acceptable_fraction: Float = 1.0f, dct_method: String = "", name: String = "DecodeJpeg") = run {
  buildOpTensor("DecodeJpeg", name) {
    addInput(contents, false)
    attr("channels", channels)
    attr("ratio", ratio)
    attr("fancy_upscaling", fancy_upscaling)
    attr("try_recover_truncated", try_recover_truncated)
    attr("acceptable_fraction", acceptable_fraction)
    attr("dct_method", dct_method)
  }
}

fun TF.decodePng(contents: Output, channels: Long = 0L, dtype: Int = DT_UINT8, name: String = "DecodePng") = run {
  buildOpTensor("DecodePng", name) {
    addInput(contents, false)
    attr("channels", channels)
    attrType("dtype", dtype)
  }
}

fun TF.drawBoundingBoxes(images: Output, boxes: Output, name: String = "DrawBoundingBoxes") = run {
  buildOpTensor("DrawBoundingBoxes", name) {
    addInput(images, false)
    addInput(boxes, false)
  }
}

fun TF.encodeJpeg(image: Output, format: String = "", quality: Long = 95L, progressive: Boolean = false, optimize_size: Boolean = false, chroma_downsampling: Boolean = true, density_unit: String = "in", x_density: Long = 300L, y_density: Long = 300L, xmp_metadata: String = "", name: String = "EncodeJpeg") = run {
  buildOpTensor("EncodeJpeg", name) {
    addInput(image, false)
    attr("format", format)
    attr("quality", quality)
    attr("progressive", progressive)
    attr("optimize_size", optimize_size)
    attr("chroma_downsampling", chroma_downsampling)
    attr("density_unit", density_unit)
    attr("x_density", x_density)
    attr("y_density", y_density)
    attr("xmp_metadata", xmp_metadata)
  }
}

fun TF.encodePng(image: Output, compression: Long = -1L, name: String = "EncodePng") = run {
  buildOpTensor("EncodePng", name) {
    addInput(image, false)
    attr("compression", compression)
  }
}

fun TF.extractGlimpse(input: Output, size: Output, offsets: Output, centered: Boolean = true, normalized: Boolean = true, uniform_noise: Boolean = true, name: String = "ExtractGlimpse") = run {
  buildOpTensor("ExtractGlimpse", name) {
    addInput(input, false)
    addInput(size, false)
    addInput(offsets, false)
    attr("centered", centered)
    attr("normalized", normalized)
    attr("uniform_noise", uniform_noise)
  }
}

fun TF.extractJpegShape(contents: Output, output_type: Int = DT_INT32, name: String = "ExtractJpegShape") = run {
  buildOpTensor("ExtractJpegShape", name) {
    addInput(contents, false)
    attrType("output_type", output_type)
  }
}

fun TF.hSVToRGB(images: Output, name: String = "HSVToRGB") = run {
  buildOpTensor("HSVToRGB", name) {
    addInput(images, false)
  }
}

fun TF.nonMaxSuppression(boxes: Output, scores: Output, max_output_size: Output, iou_threshold: Float = 0.5f, name: String = "NonMaxSuppression") = run {
  buildOpTensor("NonMaxSuppression", name) {
    addInput(boxes, false)
    addInput(scores, false)
    addInput(max_output_size, false)
    attr("iou_threshold", iou_threshold)
  }
}

fun TF.nonMaxSuppressionV2(boxes: Output, scores: Output, max_output_size: Output, iou_threshold: Output, name: String = "NonMaxSuppressionV2") = run {
  buildOpTensor("NonMaxSuppressionV2", name) {
    addInput(boxes, false)
    addInput(scores, false)
    addInput(max_output_size, false)
    addInput(iou_threshold, false)
  }
}

fun TF.nonMaxSuppressionV3(boxes: Output, scores: Output, max_output_size: Output, iou_threshold: Output, score_threshold: Output, name: String = "NonMaxSuppressionV3") = run {
  buildOpTensor("NonMaxSuppressionV3", name) {
    addInput(boxes, false)
    addInput(scores, false)
    addInput(max_output_size, false)
    addInput(iou_threshold, false)
    addInput(score_threshold, false)
  }
}

fun TF.nonMaxSuppressionWithOverlaps(overlaps: Output, scores: Output, max_output_size: Output, overlap_threshold: Output, score_threshold: Output, name: String = "NonMaxSuppressionWithOverlaps") = run {
  buildOpTensor("NonMaxSuppressionWithOverlaps", name) {
    addInput(overlaps, false)
    addInput(scores, false)
    addInput(max_output_size, false)
    addInput(overlap_threshold, false)
    addInput(score_threshold, false)
  }
}

fun TF.quantizedResizeBilinear(images: Output, size: Output, min: Output, max: Output, align_corners: Boolean = false, name: String = "QuantizedResizeBilinear") = run {
  buildOpTensors("QuantizedResizeBilinear", name) {
    addInput(images, false)
    addInput(size, false)
    addInput(min, false)
    addInput(max, false)
    attr("align_corners", align_corners)
  }
}

fun TF.rGBToHSV(images: Output, name: String = "RGBToHSV") = run {
  buildOpTensor("RGBToHSV", name) {
    addInput(images, false)
  }
}

fun TF.resizeArea(images: Output, size: Output, align_corners: Boolean = false, name: String = "ResizeArea") = run {
  buildOpTensor("ResizeArea", name) {
    addInput(images, false)
    addInput(size, false)
    attr("align_corners", align_corners)
  }
}

fun TF.resizeBicubic(images: Output, size: Output, align_corners: Boolean = false, name: String = "ResizeBicubic") = run {
  buildOpTensor("ResizeBicubic", name) {
    addInput(images, false)
    addInput(size, false)
    attr("align_corners", align_corners)
  }
}

fun TF.resizeBilinear(images: Output, size: Output, align_corners: Boolean = false, name: String = "ResizeBilinear") = run {
  buildOpTensor("ResizeBilinear", name) {
    addInput(images, false)
    addInput(size, false)
    attr("align_corners", align_corners)
  }
}

fun TF.resizeNearestNeighbor(images: Output, size: Output, align_corners: Boolean = false, name: String = "ResizeNearestNeighbor") = run {
  buildOpTensor("ResizeNearestNeighbor", name) {
    addInput(images, false)
    addInput(size, false)
    attr("align_corners", align_corners)
  }
}

fun TF.sampleDistortedBoundingBox(image_size: Output, bounding_boxes: Output, seed: Long = 0L, seed2: Long = 0L, min_object_covered: Float = 0.1f, aspect_ratio_range: Array<Float> = arrayOf(0.75f, 1.33f), area_range: Array<Float> = arrayOf(0.05f, 1.0f), max_attempts: Long = 100L, use_image_if_no_bounding_boxes: Boolean = false, name: String = "SampleDistortedBoundingBox") = run {
  buildOpTensors("SampleDistortedBoundingBox", name) {
    addInput(image_size, false)
    addInput(bounding_boxes, false)
    attr("seed", seed)
    attr("seed2", seed2)
    attr("min_object_covered", min_object_covered)
    attr("aspect_ratio_range", aspect_ratio_range)
    attr("area_range", area_range)
    attr("max_attempts", max_attempts)
    attr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes)
  }
}

fun TF.sampleDistortedBoundingBoxV2(image_size: Output, bounding_boxes: Output, min_object_covered: Output, seed: Long = 0L, seed2: Long = 0L, aspect_ratio_range: Array<Float> = arrayOf(0.75f, 1.33f), area_range: Array<Float> = arrayOf(0.05f, 1.0f), max_attempts: Long = 100L, use_image_if_no_bounding_boxes: Boolean = false, name: String = "SampleDistortedBoundingBoxV2") = run {
  buildOpTensors("SampleDistortedBoundingBoxV2", name) {
    addInput(image_size, false)
    addInput(bounding_boxes, false)
    addInput(min_object_covered, false)
    attr("seed", seed)
    attr("seed2", seed2)
    attr("aspect_ratio_range", aspect_ratio_range)
    attr("area_range", area_range)
    attr("max_attempts", max_attempts)
    attr("use_image_if_no_bounding_boxes", use_image_if_no_bounding_boxes)
  }
}

fun TF.resizeBicubicGrad(grads: Output, original_image: Output, align_corners: Boolean = false, name: String = "ResizeBicubicGrad") = run {
  buildOpTensor("ResizeBicubicGrad", name) {
    addInput(grads, false)
    addInput(original_image, false)
    attr("align_corners", align_corners)
  }
}

fun TF.resizeBilinearGrad(grads: Output, original_image: Output, align_corners: Boolean = false, name: String = "ResizeBilinearGrad") = run {
  buildOpTensor("ResizeBilinearGrad", name) {
    addInput(grads, false)
    addInput(original_image, false)
    attr("align_corners", align_corners)
  }
}

fun TF.resizeNearestNeighborGrad(grads: Output, size: Output, align_corners: Boolean = false, name: String = "ResizeNearestNeighborGrad") = run {
  buildOpTensor("ResizeNearestNeighborGrad", name) {
    addInput(grads, false)
    addInput(size, false)
    attr("align_corners", align_corners)
  }
}
