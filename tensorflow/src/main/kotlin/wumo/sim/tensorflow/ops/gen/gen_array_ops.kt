/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.tensorflow.ops.gen

import wumo.sim.tensorflow.buildOp
import wumo.sim.tensorflow.buildOpTensor
import wumo.sim.tensorflow.buildOpTensors
import wumo.sim.tensorflow.ops.Output
import wumo.sim.tensorflow.types.DataType
import wumo.sim.tensorflow.types.INT32
import wumo.sim.util.Shape

interface gen_array_ops {
  fun batchToSpace(input: Output, crops: Output, block_size: Long, name: String = "BatchToSpace") = run {
    buildOpTensor("BatchToSpace", name) {
      addInput(input, false)
      addInput(crops, false)
      attr("block_size", block_size)
    }
  }
  
  fun batchToSpaceND(input: Output, block_shape: Output, crops: Output, name: String = "BatchToSpaceND") = run {
    buildOpTensor("BatchToSpaceND", name) {
      addInput(input, false)
      addInput(block_shape, false)
      addInput(crops, false)
    }
  }
  
  fun bitcast(input: Output, _type: DataType<*>, name: String = "Bitcast") = run {
    buildOpTensor("Bitcast", name) {
      addInput(input, false)
      attr("type", _type)
    }
  }
  
  fun broadcastArgs(s0: Output, s1: Output, name: String = "BroadcastArgs") = run {
    buildOpTensor("BroadcastArgs", name) {
      addInput(s0, false)
      addInput(s1, false)
    }
  }
  
  fun broadcastTo(input: Output, shape: Output, name: String = "BroadcastTo") = run {
    buildOpTensor("BroadcastTo", name) {
      addInput(input, false)
      addInput(shape, false)
    }
  }
  
  fun checkNumerics(tensor: Output, message: String, name: String = "CheckNumerics") = run {
    buildOpTensor("CheckNumerics", name) {
      addInput(tensor, false)
      attr("message", message)
    }
  }
  
  fun concatV2(values: List<Output>, axis: Output, name: String = "ConcatV2") = run {
    buildOpTensor("ConcatV2", name) {
      addInput(values, false)
      addInput(axis, false)
    }
  }
  
  fun conjugateTranspose(x: Output, perm: Output, name: String = "ConjugateTranspose") = run {
    buildOpTensor("ConjugateTranspose", name) {
      addInput(x, false)
      addInput(perm, false)
    }
  }
  
  fun debugGradientIdentity(input: Output, name: String = "DebugGradientIdentity") = run {
    buildOpTensor("DebugGradientIdentity", name) {
      addInput(input, false)
    }
  }
  
  fun debugGradientRefIdentity(input: Output, name: String = "DebugGradientRefIdentity") = run {
    buildOpTensor("DebugGradientRefIdentity", name) {
      addInput(input, true)
    }
  }
  
  fun deepCopy(x: Output, name: String = "DeepCopy") = run {
    buildOpTensor("DeepCopy", name) {
      addInput(x, false)
    }
  }
  
  fun depthToSpace(input: Output, block_size: Long, data_format: String = "NHWC", name: String = "DepthToSpace") = run {
    buildOpTensor("DepthToSpace", name) {
      addInput(input, false)
      attr("block_size", block_size)
      attr("data_format", data_format)
    }
  }
  
  fun dequantize(input: Output, min_range: Output, max_range: Output, mode: String = "MIN_COMBINED", name: String = "Dequantize") = run {
    buildOpTensor("Dequantize", name) {
      addInput(input, false)
      addInput(min_range, false)
      addInput(max_range, false)
      attr("mode", mode)
    }
  }
  
  fun diag(diagonal: Output, name: String = "Diag") = run {
    buildOpTensor("Diag", name) {
      addInput(diagonal, false)
    }
  }
  
  fun diagPart(input: Output, name: String = "DiagPart") = run {
    buildOpTensor("DiagPart", name) {
      addInput(input, false)
    }
  }
  
  fun editDistance(hypothesis_indices: Output, hypothesis_values: Output, hypothesis_shape: Output, truth_indices: Output, truth_values: Output, truth_shape: Output, normalize: Boolean = true, name: String = "EditDistance") = run {
    buildOpTensor("EditDistance", name) {
      addInput(hypothesis_indices, false)
      addInput(hypothesis_values, false)
      addInput(hypothesis_shape, false)
      addInput(truth_indices, false)
      addInput(truth_values, false)
      addInput(truth_shape, false)
      attr("normalize", normalize)
    }
  }
  
  fun empty(shape: Output, dtype: DataType<*>, init: Boolean = false, name: String = "Empty") = run {
    buildOpTensor("Empty", name) {
      addInput(shape, false)
      attr("dtype", dtype)
      attr("init", init)
    }
  }
  
  fun expandDims(input: Output, dim: Output, name: String = "ExpandDims") = run {
    buildOpTensor("ExpandDims", name) {
      addInput(input, false)
      addInput(dim, false)
    }
  }
  
  fun extractImagePatches(images: Output, ksizes: Array<Long>, strides: Array<Long>, rates: Array<Long>, padding: String, name: String = "ExtractImagePatches") = run {
    buildOpTensor("ExtractImagePatches", name) {
      addInput(images, false)
      attr("ksizes", ksizes)
      attr("strides", strides)
      attr("rates", rates)
      attr("padding", padding)
    }
  }
  
  fun fakeQuantWithMinMaxArgs(inputs: Output, min: Float = -6.0f, max: Float = 6.0f, num_bits: Long = 8L, narrow_range: Boolean = false, name: String = "FakeQuantWithMinMaxArgs") = run {
    buildOpTensor("FakeQuantWithMinMaxArgs", name) {
      addInput(inputs, false)
      attr("min", min)
      attr("max", max)
      attr("num_bits", num_bits)
      attr("narrow_range", narrow_range)
    }
  }
  
  fun fakeQuantWithMinMaxArgsGradient(gradients: Output, inputs: Output, min: Float = -6.0f, max: Float = 6.0f, num_bits: Long = 8L, narrow_range: Boolean = false, name: String = "FakeQuantWithMinMaxArgsGradient") = run {
    buildOpTensor("FakeQuantWithMinMaxArgsGradient", name) {
      addInput(gradients, false)
      addInput(inputs, false)
      attr("min", min)
      attr("max", max)
      attr("num_bits", num_bits)
      attr("narrow_range", narrow_range)
    }
  }
  
  fun fakeQuantWithMinMaxVars(inputs: Output, min: Output, max: Output, num_bits: Long = 8L, narrow_range: Boolean = false, name: String = "FakeQuantWithMinMaxVars") = run {
    buildOpTensor("FakeQuantWithMinMaxVars", name) {
      addInput(inputs, false)
      addInput(min, false)
      addInput(max, false)
      attr("num_bits", num_bits)
      attr("narrow_range", narrow_range)
    }
  }
  
  fun fakeQuantWithMinMaxVarsGradient(gradients: Output, inputs: Output, min: Output, max: Output, num_bits: Long = 8L, narrow_range: Boolean = false, name: String = "FakeQuantWithMinMaxVarsGradient") = run {
    buildOpTensors("FakeQuantWithMinMaxVarsGradient", name) {
      addInput(gradients, false)
      addInput(inputs, false)
      addInput(min, false)
      addInput(max, false)
      attr("num_bits", num_bits)
      attr("narrow_range", narrow_range)
    }
  }
  
  fun fakeQuantWithMinMaxVarsPerChannel(inputs: Output, min: Output, max: Output, num_bits: Long = 8L, narrow_range: Boolean = false, name: String = "FakeQuantWithMinMaxVarsPerChannel") = run {
    buildOpTensor("FakeQuantWithMinMaxVarsPerChannel", name) {
      addInput(inputs, false)
      addInput(min, false)
      addInput(max, false)
      attr("num_bits", num_bits)
      attr("narrow_range", narrow_range)
    }
  }
  
  fun fakeQuantWithMinMaxVarsPerChannelGradient(gradients: Output, inputs: Output, min: Output, max: Output, num_bits: Long = 8L, narrow_range: Boolean = false, name: String = "FakeQuantWithMinMaxVarsPerChannelGradient") = run {
    buildOpTensors("FakeQuantWithMinMaxVarsPerChannelGradient", name) {
      addInput(gradients, false)
      addInput(inputs, false)
      addInput(min, false)
      addInput(max, false)
      attr("num_bits", num_bits)
      attr("narrow_range", narrow_range)
    }
  }
  
  fun fill(dims: Output, value: Output, name: String = "Fill") = run {
    buildOpTensor("Fill", name) {
      addInput(dims, false)
      addInput(value, false)
    }
  }
  
  fun _gather(params: Output, indices: Output, validate_indices: Boolean = true, name: String = "Gather") = run {
    buildOpTensor("Gather", name) {
      addInput(params, false)
      addInput(indices, false)
      attr("validate_indices", validate_indices)
    }
  }
  
  fun gatherNd(params: Output, indices: Output, name: String = "GatherNd") = run {
    buildOpTensor("GatherNd", name) {
      addInput(params, false)
      addInput(indices, false)
    }
  }
  
  fun gatherV2(params: Output, indices: Output, axis: Output, name: String = "GatherV2") = run {
    buildOpTensor("GatherV2", name) {
      addInput(params, false)
      addInput(indices, false)
      addInput(axis, false)
    }
  }
  
  fun guaranteeConst(input: Output, name: String = "GuaranteeConst") = run {
    buildOpTensor("GuaranteeConst", name) {
      addInput(input, false)
    }
  }
  
  fun identity(input: Output, name: String = "Identity") = run {
    buildOpTensor("Identity", name) {
      addInput(input, false)
    }
  }
  
  fun identityN(input: Output, name: String = "IdentityN") = run {
    buildOpTensors("IdentityN", name) {
      addInput(input, false)
    }
  }
  
  fun immutableConst(dtype: DataType<*>, shape: Shape, memory_region_name: String, name: String = "ImmutableConst") = run {
    buildOpTensor("ImmutableConst", name) {
      attr("dtype", dtype)
      attr("shape", shape)
      attr("memory_region_name", memory_region_name)
    }
  }
  
  fun inplaceAdd(x: Output, i: Output, v: Output, name: String = "InplaceAdd") = run {
    buildOpTensor("InplaceAdd", name) {
      addInput(x, false)
      addInput(i, false)
      addInput(v, false)
    }
  }
  
  fun inplaceSub(x: Output, i: Output, v: Output, name: String = "InplaceSub") = run {
    buildOpTensor("InplaceSub", name) {
      addInput(x, false)
      addInput(i, false)
      addInput(v, false)
    }
  }
  
  fun inplaceUpdate(x: Output, i: Output, v: Output, name: String = "InplaceUpdate") = run {
    buildOpTensor("InplaceUpdate", name) {
      addInput(x, false)
      addInput(i, false)
      addInput(v, false)
    }
  }
  
  fun invertPermutation(x: Output, name: String = "InvertPermutation") = run {
    buildOpTensor("InvertPermutation", name) {
      addInput(x, false)
    }
  }
  
  fun listDiff(x: Output, y: Output, out_idx: DataType<*> = INT32, name: String = "ListDiff") = run {
    buildOpTensors("ListDiff", name) {
      addInput(x, false)
      addInput(y, false)
      attr("out_idx", out_idx)
    }
  }
  
  fun matrixBandPart(input: Output, num_lower: Output, num_upper: Output, name: String = "MatrixBandPart") = run {
    buildOpTensor("MatrixBandPart", name) {
      addInput(input, false)
      addInput(num_lower, false)
      addInput(num_upper, false)
    }
  }
  
  fun matrixDiag(diagonal: Output, name: String = "MatrixDiag") = run {
    buildOpTensor("MatrixDiag", name) {
      addInput(diagonal, false)
    }
  }
  
  fun matrixDiagPart(input: Output, name: String = "MatrixDiagPart") = run {
    buildOpTensor("MatrixDiagPart", name) {
      addInput(input, false)
    }
  }
  
  fun matrixSetDiag(input: Output, diagonal: Output, name: String = "MatrixSetDiag") = run {
    buildOpTensor("MatrixSetDiag", name) {
      addInput(input, false)
      addInput(diagonal, false)
    }
  }
  
  fun mirrorPad(input: Output, paddings: Output, mode: String, name: String = "MirrorPad") = run {
    buildOpTensor("MirrorPad", name) {
      addInput(input, false)
      addInput(paddings, false)
      attr("mode", mode)
    }
  }
  
  fun _oneHot(indices: Output, depth: Output, on_value: Output, off_value: Output, axis: Long = -1L, name: String = "OneHot") = run {
    buildOpTensor("OneHot", name) {
      addInput(indices, false)
      addInput(depth, false)
      addInput(on_value, false)
      addInput(off_value, false)
      attr("axis", axis)
    }
  }
  
  fun onesLike(x: Output, name: String = "OnesLike") = run {
    buildOpTensor("OnesLike", name) {
      addInput(x, false)
    }
  }
  
  fun pack(values: List<Output>, axis: Long = 0L, name: String = "Pack") = run {
    buildOpTensor("Pack", name) {
      addInput(values, false)
      attr("axis", axis)
    }
  }
  
  fun pad(input: Output, paddings: Output, name: String = "Pad") = run {
    buildOpTensor("Pad", name) {
      addInput(input, false)
      addInput(paddings, false)
    }
  }
  
  fun padV2(input: Output, paddings: Output, constant_values: Output, name: String = "PadV2") = run {
    buildOpTensor("PadV2", name) {
      addInput(input, false)
      addInput(paddings, false)
      addInput(constant_values, false)
    }
  }
  
  fun parallelConcat(values: List<Output>, shape: Shape, name: String = "ParallelConcat") = run {
    buildOpTensor("ParallelConcat", name) {
      addInput(values, false)
      attr("shape", shape)
    }
  }
  
  fun placeholder(dtype: DataType<*>, shape: Shape = Shape(), name: String = "Placeholder") = run {
    buildOpTensor("Placeholder", name) {
      attr("dtype", dtype)
      attr("shape", shape)
    }
  }
  
  fun placeholderWithDefault(input: Output, shape: Shape, name: String = "PlaceholderWithDefault") = run {
    buildOpTensor("PlaceholderWithDefault", name) {
      addInput(input, false)
      attr("shape", shape)
    }
  }
  
  fun preventGradient(input: Output, message: String = "", name: String = "PreventGradient") = run {
    buildOpTensor("PreventGradient", name) {
      addInput(input, false)
      attr("message", message)
    }
  }
  
  fun quantizeAndDequantizeV2(input: Output, input_min: Output, input_max: Output, signed_input: Boolean = true, num_bits: Long = 8L, range_given: Boolean = false, name: String = "QuantizeAndDequantizeV2") = run {
    buildOpTensor("QuantizeAndDequantizeV2", name) {
      addInput(input, false)
      addInput(input_min, false)
      addInput(input_max, false)
      attr("signed_input", signed_input)
      attr("num_bits", num_bits)
      attr("range_given", range_given)
    }
  }
  
  fun quantizeAndDequantizeV3(input: Output, input_min: Output, input_max: Output, num_bits: Output, signed_input: Boolean = true, range_given: Boolean = true, name: String = "QuantizeAndDequantizeV3") = run {
    buildOpTensor("QuantizeAndDequantizeV3", name) {
      addInput(input, false)
      addInput(input_min, false)
      addInput(input_max, false)
      addInput(num_bits, false)
      attr("signed_input", signed_input)
      attr("range_given", range_given)
    }
  }
  
  fun quantizeV2(input: Output, min_range: Output, max_range: Output, t: DataType<*>, mode: String = "MIN_COMBINED", round_mode: String = "HALF_AWAY_FROM_ZERO", name: String = "QuantizeV2") = run {
    buildOpTensors("QuantizeV2", name) {
      addInput(input, false)
      addInput(min_range, false)
      addInput(max_range, false)
      attr("T", t)
      attr("mode", mode)
      attr("round_mode", round_mode)
    }
  }
  
  fun quantizedConcat(concat_dim: Output, values: List<Output>, input_mins: List<Output>, input_maxes: List<Output>, name: String = "QuantizedConcat") = run {
    buildOpTensors("QuantizedConcat", name) {
      addInput(concat_dim, false)
      addInput(values, false)
      addInput(input_mins, false)
      addInput(input_maxes, false)
    }
  }
  
  fun quantizedInstanceNorm(x: Output, x_min: Output, x_max: Output, output_range_given: Boolean = false, given_y_min: Float = 0.0f, given_y_max: Float = 0.0f, variance_epsilon: Float = 1.0E-5f, min_separation: Float = 0.001f, name: String = "QuantizedInstanceNorm") = run {
    buildOpTensors("QuantizedInstanceNorm", name) {
      addInput(x, false)
      addInput(x_min, false)
      addInput(x_max, false)
      attr("output_range_given", output_range_given)
      attr("given_y_min", given_y_min)
      attr("given_y_max", given_y_max)
      attr("variance_epsilon", variance_epsilon)
      attr("min_separation", min_separation)
    }
  }
  
  fun quantizedReshape(tensor: Output, shape: Output, input_min: Output, input_max: Output, name: String = "QuantizedReshape") = run {
    buildOpTensors("QuantizedReshape", name) {
      addInput(tensor, false)
      addInput(shape, false)
      addInput(input_min, false)
      addInput(input_max, false)
    }
  }
  
  fun rank(input: Output, name: String = "Rank") = run {
    buildOpTensor("Rank", name) {
      addInput(input, false)
    }
  }
  
  fun reshape(tensor: Output, shape: Output, name: String = "Reshape") = run {
    buildOpTensor("Reshape", name) {
      addInput(tensor, false)
      addInput(shape, false)
    }
  }
  
  fun resourceStridedSliceAssign(_ref: Output, begin: Output, end: Output, strides: Output, value: Output, begin_mask: Long = 0L, end_mask: Long = 0L, ellipsis_mask: Long = 0L, new_axis_mask: Long = 0L, shrink_axis_mask: Long = 0L, name: String = "ResourceStridedSliceAssign") = run {
    buildOp("ResourceStridedSliceAssign", name) {
      addInput(_ref, false)
      addInput(begin, false)
      addInput(end, false)
      addInput(strides, false)
      addInput(value, false)
      attr("begin_mask", begin_mask)
      attr("end_mask", end_mask)
      attr("ellipsis_mask", ellipsis_mask)
      attr("new_axis_mask", new_axis_mask)
      attr("shrink_axis_mask", shrink_axis_mask)
    }
  }
  
  fun reverseSequence(input: Output, seq_lengths: Output, seq_dim: Long, batch_dim: Long = 0L, name: String = "ReverseSequence") = run {
    buildOpTensor("ReverseSequence", name) {
      addInput(input, false)
      addInput(seq_lengths, false)
      attr("seq_dim", seq_dim)
      attr("batch_dim", batch_dim)
    }
  }
  
  fun reverseV2(tensor: Output, axis: Output, name: String = "ReverseV2") = run {
    buildOpTensor("ReverseV2", name) {
      addInput(tensor, false)
      addInput(axis, false)
    }
  }
  
  fun scatterNd(indices: Output, updates: Output, shape: Output, name: String = "ScatterNd") = run {
    buildOpTensor("ScatterNd", name) {
      addInput(indices, false)
      addInput(updates, false)
      addInput(shape, false)
    }
  }
  
  fun scatterNdNonAliasingAdd(input: Output, indices: Output, updates: Output, name: String = "ScatterNdNonAliasingAdd") = run {
    buildOpTensor("ScatterNdNonAliasingAdd", name) {
      addInput(input, false)
      addInput(indices, false)
      addInput(updates, false)
    }
  }
  
  fun shape(input: Output, out_type: DataType<*> = INT32, name: String = "Shape") = run {
    buildOpTensor("Shape", name) {
      addInput(input, false)
      attr("out_type", out_type)
    }
  }
  
  fun shapeN(input: List<Output>, out_type: DataType<*> = INT32, name: String = "ShapeN") = run {
    buildOpTensors("ShapeN", name) {
      addInput(input, false)
      attr("out_type", out_type)
    }
  }
  
  fun size(input: Output, out_type: DataType<*> = INT32, name: String = "Size") = run {
    buildOpTensor("Size", name) {
      addInput(input, false)
      attr("out_type", out_type)
    }
  }
  
  fun slice(input: Output, begin: Output, size: Output, name: String = "Slice") = run {
    buildOpTensor("Slice", name) {
      addInput(input, false)
      addInput(begin, false)
      addInput(size, false)
    }
  }
  
  fun snapshot(input: Output, name: String = "Snapshot") = run {
    buildOpTensor("Snapshot", name) {
      addInput(input, false)
    }
  }
  
  fun spaceToBatch(input: Output, paddings: Output, block_size: Long, name: String = "SpaceToBatch") = run {
    buildOpTensor("SpaceToBatch", name) {
      addInput(input, false)
      addInput(paddings, false)
      attr("block_size", block_size)
    }
  }
  
  fun spaceToBatchND(input: Output, block_shape: Output, paddings: Output, name: String = "SpaceToBatchND") = run {
    buildOpTensor("SpaceToBatchND", name) {
      addInput(input, false)
      addInput(block_shape, false)
      addInput(paddings, false)
    }
  }
  
  fun spaceToDepth(input: Output, block_size: Long, data_format: String = "NHWC", name: String = "SpaceToDepth") = run {
    buildOpTensor("SpaceToDepth", name) {
      addInput(input, false)
      attr("block_size", block_size)
      attr("data_format", data_format)
    }
  }
  
  fun split(split_dim: Output, value: Output, num_split: Long, name: String = "Split") = run {
    buildOpTensors("Split", name) {
      addInput(split_dim, false)
      addInput(value, false)
      attr("num_split", num_split)
    }
  }
  
  fun splitV(value: Output, size_splits: Output, split_dim: Output, num_split: Long, name: String = "SplitV") = run {
    buildOpTensors("SplitV", name) {
      addInput(value, false)
      addInput(size_splits, false)
      addInput(split_dim, false)
      attr("num_split", num_split)
    }
  }
  
  fun squeeze(input: Output, squeeze_dims: Array<Long> = arrayOf(), name: String = "Squeeze") = run {
    buildOpTensor("Squeeze", name) {
      addInput(input, false)
      attr("squeeze_dims", squeeze_dims)
    }
  }
  
  fun stopGradient(input: Output, name: String = "StopGradient") = run {
    buildOpTensor("StopGradient", name) {
      addInput(input, false)
    }
  }
  
  fun stridedSlice(input: Output, begin: Output, end: Output, strides: Output, begin_mask: Long = 0L, end_mask: Long = 0L, ellipsis_mask: Long = 0L, new_axis_mask: Long = 0L, shrink_axis_mask: Long = 0L, name: String = "StridedSlice") = run {
    buildOpTensor("StridedSlice", name) {
      addInput(input, false)
      addInput(begin, false)
      addInput(end, false)
      addInput(strides, false)
      attr("begin_mask", begin_mask)
      attr("end_mask", end_mask)
      attr("ellipsis_mask", ellipsis_mask)
      attr("new_axis_mask", new_axis_mask)
      attr("shrink_axis_mask", shrink_axis_mask)
    }
  }
  
  fun stridedSliceAssign(_ref: Output, begin: Output, end: Output, strides: Output, value: Output, begin_mask: Long = 0L, end_mask: Long = 0L, ellipsis_mask: Long = 0L, new_axis_mask: Long = 0L, shrink_axis_mask: Long = 0L, name: String = "StridedSliceAssign") = run {
    buildOpTensor("StridedSliceAssign", name) {
      addInput(_ref, true)
      addInput(begin, false)
      addInput(end, false)
      addInput(strides, false)
      addInput(value, false)
      attr("begin_mask", begin_mask)
      attr("end_mask", end_mask)
      attr("ellipsis_mask", ellipsis_mask)
      attr("new_axis_mask", new_axis_mask)
      attr("shrink_axis_mask", shrink_axis_mask)
    }
  }
  
  fun stridedSliceGrad(shape: Output, begin: Output, end: Output, strides: Output, dy: Output, begin_mask: Long = 0L, end_mask: Long = 0L, ellipsis_mask: Long = 0L, new_axis_mask: Long = 0L, shrink_axis_mask: Long = 0L, name: String = "StridedSliceGrad") = run {
    buildOpTensor("StridedSliceGrad", name) {
      addInput(shape, false)
      addInput(begin, false)
      addInput(end, false)
      addInput(strides, false)
      addInput(dy, false)
      attr("begin_mask", begin_mask)
      attr("end_mask", end_mask)
      attr("ellipsis_mask", ellipsis_mask)
      attr("new_axis_mask", new_axis_mask)
      attr("shrink_axis_mask", shrink_axis_mask)
    }
  }
  
  fun tile(input: Output, multiples: Output, name: String = "Tile") = run {
    buildOpTensor("Tile", name) {
      addInput(input, false)
      addInput(multiples, false)
    }
  }
  
  fun transpose(x: Output, perm: Output, name: String = "Transpose") = run {
    buildOpTensor("Transpose", name) {
      addInput(x, false)
      addInput(perm, false)
    }
  }
  
  fun unique(x: Output, out_idx: DataType<*> = INT32, name: String = "Unique") = run {
    buildOpTensors("Unique", name) {
      addInput(x, false)
      attr("out_idx", out_idx)
    }
  }
  
  fun uniqueV2(x: Output, axis: Output, out_idx: DataType<*> = INT32, name: String = "UniqueV2") = run {
    buildOpTensors("UniqueV2", name) {
      addInput(x, false)
      addInput(axis, false)
      attr("out_idx", out_idx)
    }
  }
  
  fun uniqueWithCounts(x: Output, out_idx: DataType<*> = INT32, name: String = "UniqueWithCounts") = run {
    buildOpTensors("UniqueWithCounts", name) {
      addInput(x, false)
      attr("out_idx", out_idx)
    }
  }
  
  fun uniqueWithCountsV2(x: Output, axis: Output, out_idx: DataType<*> = INT32, name: String = "UniqueWithCountsV2") = run {
    buildOpTensors("UniqueWithCountsV2", name) {
      addInput(x, false)
      addInput(axis, false)
      attr("out_idx", out_idx)
    }
  }
  
  fun unpack(value: Output, num: Long, axis: Long = 0L, name: String = "Unpack") = run {
    buildOpTensors("Unpack", name) {
      addInput(value, false)
      attr("num", num)
      attr("axis", axis)
    }
  }
  
  fun unravelIndex(indices: Output, dims: Output, name: String = "UnravelIndex") = run {
    buildOpTensor("UnravelIndex", name) {
      addInput(indices, false)
      addInput(dims, false)
    }
  }
  
  fun where(input: Output, name: String = "Where") = run {
    buildOpTensor("Where", name) {
      addInput(input, false)
    }
  }
  
  fun zerosLike(x: Output, name: String = "ZerosLike") = run {
    buildOpTensor("ZerosLike", name) {
      addInput(x, false)
    }
  }
  
  fun broadcastGradientArgs(s0: Output, s1: Output, name: String = "BroadcastGradientArgs") = run {
    buildOpTensors("BroadcastGradientArgs", name) {
      addInput(s0, false)
      addInput(s1, false)
    }
  }
  
  fun mirrorPadGrad(input: Output, paddings: Output, mode: String, name: String = "MirrorPadGrad") = run {
    buildOpTensor("MirrorPadGrad", name) {
      addInput(input, false)
      addInput(paddings, false)
      attr("mode", mode)
    }
  }
  
  fun refIdentity(input: Output, name: String = "RefIdentity") = run {
    buildOpTensor("RefIdentity", name) {
      addInput(input, true)
    }
  }
}