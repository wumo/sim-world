/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.tensorflow.ops.gen

import wumo.sim.tensorflow.buildOp
import wumo.sim.tensorflow.buildOpTensor
import wumo.sim.tensorflow.ops.Output

interface gen_training_ops {
  fun applyAdadelta(_var: Output, accum: Output, accumUpdate: Output, lr: Output, rho: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ApplyAdadelta") = run {
    buildOpTensor("ApplyAdadelta", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(accumUpdate, true)
      addInput(lr, false)
      addInput(rho, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyAdagrad(_var: Output, accum: Output, lr: Output, grad: Output, useLocking: Boolean = false, updateSlots: Boolean = true, name: String = "ApplyAdagrad") = run {
    buildOpTensor("ApplyAdagrad", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(lr, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
      attr("update_slots", updateSlots)
    }
  }
  
  fun applyAdagradDA(_var: Output, gradientAccumulator: Output, gradientSquaredAccumulator: Output, grad: Output, lr: Output, l1: Output, l2: Output, globalStep: Output, useLocking: Boolean = false, name: String = "ApplyAdagradDA") = run {
    buildOpTensor("ApplyAdagradDA", name) {
      addInput(_var, true)
      addInput(gradientAccumulator, true)
      addInput(gradientSquaredAccumulator, true)
      addInput(grad, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(globalStep, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyAdam(_var: Output, m: Output, v: Output, beta1Power: Output, beta2Power: Output, lr: Output, beta1: Output, beta2: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, useNesterov: Boolean = false, name: String = "ApplyAdam") = run {
    buildOpTensor("ApplyAdam", name) {
      addInput(_var, true)
      addInput(m, true)
      addInput(v, true)
      addInput(beta1Power, false)
      addInput(beta2Power, false)
      addInput(lr, false)
      addInput(beta1, false)
      addInput(beta2, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
      attr("use_nesterov", useNesterov)
    }
  }
  
  fun applyAddSign(_var: Output, m: Output, lr: Output, alpha: Output, signDecay: Output, beta: Output, grad: Output, useLocking: Boolean = false, name: String = "ApplyAddSign") = run {
    buildOpTensor("ApplyAddSign", name) {
      addInput(_var, true)
      addInput(m, true)
      addInput(lr, false)
      addInput(alpha, false)
      addInput(signDecay, false)
      addInput(beta, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyCenteredRMSProp(_var: Output, mg: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ApplyCenteredRMSProp") = run {
    buildOpTensor("ApplyCenteredRMSProp", name) {
      addInput(_var, true)
      addInput(mg, true)
      addInput(ms, true)
      addInput(mom, true)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyFtrl(_var: Output, accum: Output, linear: Output, grad: Output, lr: Output, l1: Output, l2: Output, lrPower: Output, useLocking: Boolean = false, name: String = "ApplyFtrl") = run {
    buildOpTensor("ApplyFtrl", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(linear, true)
      addInput(grad, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyFtrlV2(_var: Output, accum: Output, linear: Output, grad: Output, lr: Output, l1: Output, l2: Output, l2Shrinkage: Output, lrPower: Output, useLocking: Boolean = false, name: String = "ApplyFtrlV2") = run {
    buildOpTensor("ApplyFtrlV2", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(linear, true)
      addInput(grad, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(l2Shrinkage, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyGradientDescent(_var: Output, alpha: Output, delta: Output, useLocking: Boolean = false, name: String = "ApplyGradientDescent") = run {
    buildOpTensor("ApplyGradientDescent", name) {
      addInput(_var, true)
      addInput(alpha, false)
      addInput(delta, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyMomentum(_var: Output, accum: Output, lr: Output, grad: Output, momentum: Output, useLocking: Boolean = false, useNesterov: Boolean = false, name: String = "ApplyMomentum") = run {
    buildOpTensor("ApplyMomentum", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(lr, false)
      addInput(grad, false)
      addInput(momentum, false)
      attr("use_locking", useLocking)
      attr("use_nesterov", useNesterov)
    }
  }
  
  fun applyPowerSign(_var: Output, m: Output, lr: Output, logbase: Output, signDecay: Output, beta: Output, grad: Output, useLocking: Boolean = false, name: String = "ApplyPowerSign") = run {
    buildOpTensor("ApplyPowerSign", name) {
      addInput(_var, true)
      addInput(m, true)
      addInput(lr, false)
      addInput(logbase, false)
      addInput(signDecay, false)
      addInput(beta, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyProximalAdagrad(_var: Output, accum: Output, lr: Output, l1: Output, l2: Output, grad: Output, useLocking: Boolean = false, name: String = "ApplyProximalAdagrad") = run {
    buildOpTensor("ApplyProximalAdagrad", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyProximalGradientDescent(_var: Output, alpha: Output, l1: Output, l2: Output, delta: Output, useLocking: Boolean = false, name: String = "ApplyProximalGradientDescent") = run {
    buildOpTensor("ApplyProximalGradientDescent", name) {
      addInput(_var, true)
      addInput(alpha, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(delta, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyRMSProp(_var: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ApplyRMSProp") = run {
    buildOpTensor("ApplyRMSProp", name) {
      addInput(_var, true)
      addInput(ms, true)
      addInput(mom, true)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyAdadelta(_var: Output, accum: Output, accumUpdate: Output, lr: Output, rho: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ResourceApplyAdadelta") = run {
    buildOp("ResourceApplyAdadelta", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(accumUpdate, false)
      addInput(lr, false)
      addInput(rho, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyAdagrad(_var: Output, accum: Output, lr: Output, grad: Output, useLocking: Boolean = false, updateSlots: Boolean = true, name: String = "ResourceApplyAdagrad") = run {
    buildOp("ResourceApplyAdagrad", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(lr, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
      attr("update_slots", updateSlots)
    }
  }
  
  fun resourceApplyAdagradDA(_var: Output, gradientAccumulator: Output, gradientSquaredAccumulator: Output, grad: Output, lr: Output, l1: Output, l2: Output, globalStep: Output, useLocking: Boolean = false, name: String = "ResourceApplyAdagradDA") = run {
    buildOp("ResourceApplyAdagradDA", name) {
      addInput(_var, false)
      addInput(gradientAccumulator, false)
      addInput(gradientSquaredAccumulator, false)
      addInput(grad, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(globalStep, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyAdam(_var: Output, m: Output, v: Output, beta1Power: Output, beta2Power: Output, lr: Output, beta1: Output, beta2: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, useNesterov: Boolean = false, name: String = "ResourceApplyAdam") = run {
    buildOp("ResourceApplyAdam", name) {
      addInput(_var, false)
      addInput(m, false)
      addInput(v, false)
      addInput(beta1Power, false)
      addInput(beta2Power, false)
      addInput(lr, false)
      addInput(beta1, false)
      addInput(beta2, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
      attr("use_nesterov", useNesterov)
    }
  }
  
  fun resourceApplyAddSign(_var: Output, m: Output, lr: Output, alpha: Output, signDecay: Output, beta: Output, grad: Output, useLocking: Boolean = false, name: String = "ResourceApplyAddSign") = run {
    buildOp("ResourceApplyAddSign", name) {
      addInput(_var, false)
      addInput(m, false)
      addInput(lr, false)
      addInput(alpha, false)
      addInput(signDecay, false)
      addInput(beta, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyCenteredRMSProp(_var: Output, mg: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ResourceApplyCenteredRMSProp") = run {
    buildOp("ResourceApplyCenteredRMSProp", name) {
      addInput(_var, false)
      addInput(mg, false)
      addInput(ms, false)
      addInput(mom, false)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyFtrl(_var: Output, accum: Output, linear: Output, grad: Output, lr: Output, l1: Output, l2: Output, lrPower: Output, useLocking: Boolean = false, name: String = "ResourceApplyFtrl") = run {
    buildOp("ResourceApplyFtrl", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(linear, false)
      addInput(grad, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyFtrlV2(_var: Output, accum: Output, linear: Output, grad: Output, lr: Output, l1: Output, l2: Output, l2Shrinkage: Output, lrPower: Output, useLocking: Boolean = false, name: String = "ResourceApplyFtrlV2") = run {
    buildOp("ResourceApplyFtrlV2", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(linear, false)
      addInput(grad, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(l2Shrinkage, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyGradientDescent(_var: Output, alpha: Output, delta: Output, useLocking: Boolean = false, name: String = "ResourceApplyGradientDescent") = run {
    buildOp("ResourceApplyGradientDescent", name) {
      addInput(_var, false)
      addInput(alpha, false)
      addInput(delta, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyMomentum(_var: Output, accum: Output, lr: Output, grad: Output, momentum: Output, useLocking: Boolean = false, useNesterov: Boolean = false, name: String = "ResourceApplyMomentum") = run {
    buildOp("ResourceApplyMomentum", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(lr, false)
      addInput(grad, false)
      addInput(momentum, false)
      attr("use_locking", useLocking)
      attr("use_nesterov", useNesterov)
    }
  }
  
  fun resourceApplyPowerSign(_var: Output, m: Output, lr: Output, logbase: Output, signDecay: Output, beta: Output, grad: Output, useLocking: Boolean = false, name: String = "ResourceApplyPowerSign") = run {
    buildOp("ResourceApplyPowerSign", name) {
      addInput(_var, false)
      addInput(m, false)
      addInput(lr, false)
      addInput(logbase, false)
      addInput(signDecay, false)
      addInput(beta, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyProximalAdagrad(_var: Output, accum: Output, lr: Output, l1: Output, l2: Output, grad: Output, useLocking: Boolean = false, name: String = "ResourceApplyProximalAdagrad") = run {
    buildOp("ResourceApplyProximalAdagrad", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyProximalGradientDescent(_var: Output, alpha: Output, l1: Output, l2: Output, delta: Output, useLocking: Boolean = false, name: String = "ResourceApplyProximalGradientDescent") = run {
    buildOp("ResourceApplyProximalGradientDescent", name) {
      addInput(_var, false)
      addInput(alpha, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(delta, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyRMSProp(_var: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ResourceApplyRMSProp") = run {
    buildOp("ResourceApplyRMSProp", name) {
      addInput(_var, false)
      addInput(ms, false)
      addInput(mom, false)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyAdadelta(_var: Output, accum: Output, accumUpdate: Output, lr: Output, rho: Output, epsilon: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyAdadelta") = run {
    buildOp("ResourceSparseApplyAdadelta", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(accumUpdate, false)
      addInput(lr, false)
      addInput(rho, false)
      addInput(epsilon, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyAdagrad(_var: Output, accum: Output, lr: Output, grad: Output, indices: Output, useLocking: Boolean = false, updateSlots: Boolean = true, name: String = "ResourceSparseApplyAdagrad") = run {
    buildOp("ResourceSparseApplyAdagrad", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(lr, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
      attr("update_slots", updateSlots)
    }
  }
  
  fun resourceSparseApplyAdagradDA(_var: Output, gradientAccumulator: Output, gradientSquaredAccumulator: Output, grad: Output, indices: Output, lr: Output, l1: Output, l2: Output, globalStep: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyAdagradDA") = run {
    buildOp("ResourceSparseApplyAdagradDA", name) {
      addInput(_var, false)
      addInput(gradientAccumulator, false)
      addInput(gradientSquaredAccumulator, false)
      addInput(grad, false)
      addInput(indices, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(globalStep, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyCenteredRMSProp(_var: Output, mg: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyCenteredRMSProp") = run {
    buildOp("ResourceSparseApplyCenteredRMSProp", name) {
      addInput(_var, false)
      addInput(mg, false)
      addInput(ms, false)
      addInput(mom, false)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyFtrl(_var: Output, accum: Output, linear: Output, grad: Output, indices: Output, lr: Output, l1: Output, l2: Output, lrPower: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyFtrl") = run {
    buildOp("ResourceSparseApplyFtrl", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(linear, false)
      addInput(grad, false)
      addInput(indices, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyFtrlV2(_var: Output, accum: Output, linear: Output, grad: Output, indices: Output, lr: Output, l1: Output, l2: Output, l2Shrinkage: Output, lrPower: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyFtrlV2") = run {
    buildOp("ResourceSparseApplyFtrlV2", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(linear, false)
      addInput(grad, false)
      addInput(indices, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(l2Shrinkage, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyMomentum(_var: Output, accum: Output, lr: Output, grad: Output, indices: Output, momentum: Output, useLocking: Boolean = false, useNesterov: Boolean = false, name: String = "ResourceSparseApplyMomentum") = run {
    buildOp("ResourceSparseApplyMomentum", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(lr, false)
      addInput(grad, false)
      addInput(indices, false)
      addInput(momentum, false)
      attr("use_locking", useLocking)
      attr("use_nesterov", useNesterov)
    }
  }
  
  fun resourceSparseApplyProximalAdagrad(_var: Output, accum: Output, lr: Output, l1: Output, l2: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyProximalAdagrad") = run {
    buildOp("ResourceSparseApplyProximalAdagrad", name) {
      addInput(_var, false)
      addInput(accum, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyProximalGradientDescent(_var: Output, alpha: Output, l1: Output, l2: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyProximalGradientDescent") = run {
    buildOp("ResourceSparseApplyProximalGradientDescent", name) {
      addInput(_var, false)
      addInput(alpha, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceSparseApplyRMSProp(_var: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "ResourceSparseApplyRMSProp") = run {
    buildOp("ResourceSparseApplyRMSProp", name) {
      addInput(_var, false)
      addInput(ms, false)
      addInput(mom, false)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyAdadelta(_var: Output, accum: Output, accumUpdate: Output, lr: Output, rho: Output, epsilon: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "SparseApplyAdadelta") = run {
    buildOpTensor("SparseApplyAdadelta", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(accumUpdate, true)
      addInput(lr, false)
      addInput(rho, false)
      addInput(epsilon, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyAdagrad(_var: Output, accum: Output, lr: Output, grad: Output, indices: Output, useLocking: Boolean = false, updateSlots: Boolean = true, name: String = "SparseApplyAdagrad") = run {
    buildOpTensor("SparseApplyAdagrad", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(lr, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
      attr("update_slots", updateSlots)
    }
  }
  
  fun sparseApplyAdagradDA(_var: Output, gradientAccumulator: Output, gradientSquaredAccumulator: Output, grad: Output, indices: Output, lr: Output, l1: Output, l2: Output, globalStep: Output, useLocking: Boolean = false, name: String = "SparseApplyAdagradDA") = run {
    buildOpTensor("SparseApplyAdagradDA", name) {
      addInput(_var, true)
      addInput(gradientAccumulator, true)
      addInput(gradientSquaredAccumulator, true)
      addInput(grad, false)
      addInput(indices, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(globalStep, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyCenteredRMSProp(_var: Output, mg: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "SparseApplyCenteredRMSProp") = run {
    buildOpTensor("SparseApplyCenteredRMSProp", name) {
      addInput(_var, true)
      addInput(mg, true)
      addInput(ms, true)
      addInput(mom, true)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyFtrl(_var: Output, accum: Output, linear: Output, grad: Output, indices: Output, lr: Output, l1: Output, l2: Output, lrPower: Output, useLocking: Boolean = false, name: String = "SparseApplyFtrl") = run {
    buildOpTensor("SparseApplyFtrl", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(linear, true)
      addInput(grad, false)
      addInput(indices, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyFtrlV2(_var: Output, accum: Output, linear: Output, grad: Output, indices: Output, lr: Output, l1: Output, l2: Output, l2Shrinkage: Output, lrPower: Output, useLocking: Boolean = false, name: String = "SparseApplyFtrlV2") = run {
    buildOpTensor("SparseApplyFtrlV2", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(linear, true)
      addInput(grad, false)
      addInput(indices, false)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(l2Shrinkage, false)
      addInput(lrPower, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyMomentum(_var: Output, accum: Output, lr: Output, grad: Output, indices: Output, momentum: Output, useLocking: Boolean = false, useNesterov: Boolean = false, name: String = "SparseApplyMomentum") = run {
    buildOpTensor("SparseApplyMomentum", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(lr, false)
      addInput(grad, false)
      addInput(indices, false)
      addInput(momentum, false)
      attr("use_locking", useLocking)
      attr("use_nesterov", useNesterov)
    }
  }
  
  fun sparseApplyProximalAdagrad(_var: Output, accum: Output, lr: Output, l1: Output, l2: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "SparseApplyProximalAdagrad") = run {
    buildOpTensor("SparseApplyProximalAdagrad", name) {
      addInput(_var, true)
      addInput(accum, true)
      addInput(lr, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyProximalGradientDescent(_var: Output, alpha: Output, l1: Output, l2: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "SparseApplyProximalGradientDescent") = run {
    buildOpTensor("SparseApplyProximalGradientDescent", name) {
      addInput(_var, true)
      addInput(alpha, false)
      addInput(l1, false)
      addInput(l2, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun sparseApplyRMSProp(_var: Output, ms: Output, mom: Output, lr: Output, rho: Output, momentum: Output, epsilon: Output, grad: Output, indices: Output, useLocking: Boolean = false, name: String = "SparseApplyRMSProp") = run {
    buildOpTensor("SparseApplyRMSProp", name) {
      addInput(_var, true)
      addInput(ms, true)
      addInput(mom, true)
      addInput(lr, false)
      addInput(rho, false)
      addInput(momentum, false)
      addInput(epsilon, false)
      addInput(grad, false)
      addInput(indices, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun applyAdaMax(_var: Output, m: Output, v: Output, beta1Power: Output, lr: Output, beta1: Output, beta2: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ApplyAdaMax") = run {
    buildOpTensor("ApplyAdaMax", name) {
      addInput(_var, true)
      addInput(m, true)
      addInput(v, true)
      addInput(beta1Power, false)
      addInput(lr, false)
      addInput(beta1, false)
      addInput(beta2, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
  
  fun resourceApplyAdaMax(_var: Output, m: Output, v: Output, beta1Power: Output, lr: Output, beta1: Output, beta2: Output, epsilon: Output, grad: Output, useLocking: Boolean = false, name: String = "ResourceApplyAdaMax") = run {
    buildOp("ResourceApplyAdaMax", name) {
      addInput(_var, false)
      addInput(m, false)
      addInput(v, false)
      addInput(beta1Power, false)
      addInput(lr, false)
      addInput(beta1, false)
      addInput(beta2, false)
      addInput(epsilon, false)
      addInput(grad, false)
      attr("use_locking", useLocking)
    }
  }
}