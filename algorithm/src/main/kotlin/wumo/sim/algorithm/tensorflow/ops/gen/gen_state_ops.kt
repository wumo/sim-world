/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import wumo.sim.algorithm.tensorflow.Tensor
import wumo.sim.algorithm.tensorflow.buildOp
import wumo.sim.algorithm.tensorflow.buildOpTensor
import wumo.sim.algorithm.tensorflow.tf
import wumo.sim.util.Dimension

object gen_state_ops {
  fun assign(_ref: Tensor, value: Tensor, validate_shape: Boolean = true, use_locking: Boolean = true, name: String = "Assign") = run {
    tf.buildOpTensor("Assign", name) {
      addInput(_ref, true)
      addInput(value, false)
      attr("validate_shape", validate_shape)
      attr("use_locking", use_locking)
    }
  }
  
  fun assignAdd(_ref: Tensor, value: Tensor, use_locking: Boolean = false, name: String = "AssignAdd") = run {
    tf.buildOpTensor("AssignAdd", name) {
      addInput(_ref, true)
      addInput(value, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun assignSub(_ref: Tensor, value: Tensor, use_locking: Boolean = false, name: String = "AssignSub") = run {
    tf.buildOpTensor("AssignSub", name) {
      addInput(_ref, true)
      addInput(value, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun countUpTo(_ref: Tensor, limit: Long, name: String = "CountUpTo") = run {
    tf.buildOpTensor("CountUpTo", name) {
      addInput(_ref, true)
      attr("limit", limit)
    }
  }
  
  fun destroyTemporaryVariable(_ref: Tensor, var_name: String, name: String = "DestroyTemporaryVariable") = run {
    tf.buildOpTensor("DestroyTemporaryVariable", name) {
      addInput(_ref, true)
      attr("var_name", var_name)
    }
  }
  
  fun isVariableInitialized(_ref: Tensor, name: String = "IsVariableInitialized") = run {
    tf.buildOpTensor("IsVariableInitialized", name) {
      addInput(_ref, true)
      
    }
  }
  
  fun resourceCountUpTo(resource: Tensor, limit: Long, t: Int, name: String = "ResourceCountUpTo") = run {
    tf.buildOpTensor("ResourceCountUpTo", name) {
      addInput(resource, false)
      attr("limit", limit)
      attrType("T", t)
    }
  }
  
  fun resourceScatterNdAdd(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = true, name: String = "ResourceScatterNdAdd") = run {
    tf.buildOp("ResourceScatterNdAdd", name) {
      addInput(_ref, false)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun resourceScatterNdUpdate(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = true, name: String = "ResourceScatterNdUpdate") = run {
    tf.buildOp("ResourceScatterNdUpdate", name) {
      addInput(_ref, false)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterAdd(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterAdd") = run {
    tf.buildOpTensor("ScatterAdd", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterDiv(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterDiv") = run {
    tf.buildOpTensor("ScatterDiv", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterMax(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterMax") = run {
    tf.buildOpTensor("ScatterMax", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterMin(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterMin") = run {
    tf.buildOpTensor("ScatterMin", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterMul(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterMul") = run {
    tf.buildOpTensor("ScatterMul", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterNdAdd(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterNdAdd") = run {
    tf.buildOpTensor("ScatterNdAdd", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterNdSub(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterNdSub") = run {
    tf.buildOpTensor("ScatterNdSub", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterNdUpdate(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = true, name: String = "ScatterNdUpdate") = run {
    tf.buildOpTensor("ScatterNdUpdate", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterSub(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = false, name: String = "ScatterSub") = run {
    tf.buildOpTensor("ScatterSub", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun scatterUpdate(_ref: Tensor, indices: Tensor, updates: Tensor, use_locking: Boolean = true, name: String = "ScatterUpdate") = run {
    tf.buildOpTensor("ScatterUpdate", name) {
      addInput(_ref, true)
      addInput(indices, false)
      addInput(updates, false)
      attr("use_locking", use_locking)
    }
  }
  
  fun temporaryVariable(shape: Dimension, dtype: Int, var_name: String = "", name: String = "TemporaryVariable") = run {
    tf.buildOpTensor("TemporaryVariable", name) {
      
      attr("shape", shape)
      attrType("dtype", dtype)
      attr("var_name", var_name)
    }
  }
  
  fun variableV2(shape: Dimension, dtype: Int, container: String = "", shared_name: String = "", name: String = "VariableV2") = run {
    tf.buildOpTensor("VariableV2", name) {
      
      attr("shape", shape)
      attrType("dtype", dtype)
      attr("container", container)
      attr("shared_name", shared_name)
    }
  }
}