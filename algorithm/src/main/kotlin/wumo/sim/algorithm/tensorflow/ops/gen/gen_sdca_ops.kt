/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import wumo.sim.algorithm.tensorflow.*

object gen_sdca_ops {
  fun sdcaFprint(input: Tensor, name: String = "SdcaFprint") = run {
    tf.buildOpTensor("SdcaFprint", name) {
      addInput(input, false)
      
    }
  }
  
  fun sdcaOptimizer(sparse_example_indices: Array<Tensor>, sparse_feature_indices: Array<Tensor>, sparse_feature_values: Array<Tensor>, dense_features: Array<Tensor>, example_weights: Tensor, example_labels: Tensor, sparse_indices: Array<Tensor>, sparse_weights: Array<Tensor>, dense_weights: Array<Tensor>, example_state_data: Tensor, loss_type: String, adaptative: Boolean = false, l1: Float, l2: Float, num_loss_partitions: Long, num_inner_iterations: Long, name: String = "SdcaOptimizer") = run {
    tf.buildOpTensors("SdcaOptimizer", name) {
      addInput(sparse_example_indices, false)
      addInput(sparse_feature_indices, false)
      addInput(sparse_feature_values, false)
      addInput(dense_features, false)
      addInput(example_weights, false)
      addInput(example_labels, false)
      addInput(sparse_indices, false)
      addInput(sparse_weights, false)
      addInput(dense_weights, false)
      addInput(example_state_data, false)
      attr("loss_type", loss_type)
      attr("adaptative", adaptative)
      attr("l1", l1)
      attr("l2", l2)
      attr("num_loss_partitions", num_loss_partitions)
      attr("num_inner_iterations", num_inner_iterations)
    }
  }
  
  fun sdcaShrinkL1(weights: Array<Tensor>, l1: Float, l2: Float, name: String = "SdcaShrinkL1") = run {
    tf.buildOp("SdcaShrinkL1", name) {
      addInput(weights, true)
      attr("l1", l1)
      attr("l2", l2)
    }
  }
}