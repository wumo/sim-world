/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import wumo.sim.algorithm.tensorflow.*

fun TF.sdcaFprint(input: Tensor, name: String = "SdcaFprint") = run {
  buildOpTensor("SdcaFprint", name) {
    addInput(input, false)
  }
}

fun TF.sdcaOptimizer(sparse_example_indices: Array<Tensor>, sparse_feature_indices: Array<Tensor>, sparse_feature_values: Array<Tensor>, dense_features: Array<Tensor>, example_weights: Tensor, example_labels: Tensor, sparse_indices: Array<Tensor>, sparse_weights: Array<Tensor>, dense_weights: Array<Tensor>, example_state_data: Tensor, loss_type: String, l1: Float, l2: Float, num_loss_partitions: Long, num_inner_iterations: Long, adaptative: Boolean = false, name: String = "SdcaOptimizer") = run {
  buildOpTensors("SdcaOptimizer", name) {
    addInput(sparse_example_indices, false)
    addInput(sparse_feature_indices, false)
    addInput(sparse_feature_values, false)
    addInput(dense_features, false)
    addInput(example_weights, false)
    addInput(example_labels, false)
    addInput(sparse_indices, false)
    addInput(sparse_weights, false)
    addInput(dense_weights, false)
    addInput(example_state_data, false)
    attr("loss_type", loss_type)
    attr("l1", l1)
    attr("l2", l2)
    attr("num_loss_partitions", num_loss_partitions)
    attr("num_inner_iterations", num_inner_iterations)
    attr("adaptative", adaptative)
  }
}

fun TF.sdcaShrinkL1(weights: Array<Tensor>, l1: Float, l2: Float, name: String = "SdcaShrinkL1") = run {
  buildOp("SdcaShrinkL1", name) {
    addInput(weights, true)
    attr("l1", l1)
    attr("l2", l2)
  }
}
