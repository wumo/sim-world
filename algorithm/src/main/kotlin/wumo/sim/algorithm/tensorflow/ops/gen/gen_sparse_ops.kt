/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import org.bytedeco.javacpp.tensorflow.DT_STRING
import wumo.sim.algorithm.tensorflow.TF
import wumo.sim.algorithm.tensorflow.Tensor
import wumo.sim.algorithm.tensorflow.buildOpTensor
import wumo.sim.algorithm.tensorflow.buildOpTensors

fun TF.addManySparseToTensorsMap(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, container: String = "", shared_name: String = "", name: String = "AddManySparseToTensorsMap") = run {
  buildOpTensor("AddManySparseToTensorsMap", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attr("container", container)
    attr("shared_name", shared_name)
  }
}

fun TF.addSparseToTensorsMap(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, container: String = "", shared_name: String = "", name: String = "AddSparseToTensorsMap") = run {
  buildOpTensor("AddSparseToTensorsMap", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attr("container", container)
    attr("shared_name", shared_name)
  }
}

fun TF.deserializeManySparse(serialized_sparse: Tensor, dtype: Int, name: String = "DeserializeManySparse") = run {
  buildOpTensors("DeserializeManySparse", name) {
    addInput(serialized_sparse, false)
    attrType("dtype", dtype)
  }
}

fun TF.deserializeSparse(serialized_sparse: Tensor, dtype: Int, name: String = "DeserializeSparse") = run {
  buildOpTensors("DeserializeSparse", name) {
    addInput(serialized_sparse, false)
    attrType("dtype", dtype)
  }
}

fun TF.serializeManySparse(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, out_type: Int = DT_STRING, name: String = "SerializeManySparse") = run {
  buildOpTensor("SerializeManySparse", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attrType("out_type", out_type)
  }
}

fun TF.serializeSparse(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, out_type: Int = DT_STRING, name: String = "SerializeSparse") = run {
  buildOpTensor("SerializeSparse", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attrType("out_type", out_type)
  }
}

fun TF.sparseAdd(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b_indices: Tensor, b_values: Tensor, b_shape: Tensor, thresh: Tensor, name: String = "SparseAdd") = run {
  buildOpTensors("SparseAdd", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b_indices, false)
    addInput(b_values, false)
    addInput(b_shape, false)
    addInput(thresh, false)
  }
}

fun TF.sparseAddGrad(backprop_val_grad: Tensor, a_indices: Tensor, b_indices: Tensor, sum_indices: Tensor, name: String = "SparseAddGrad") = run {
  buildOpTensors("SparseAddGrad", name) {
    addInput(backprop_val_grad, false)
    addInput(a_indices, false)
    addInput(b_indices, false)
    addInput(sum_indices, false)
  }
}

fun TF.sparseConcat(indices: Array<Tensor>, values: Array<Tensor>, shapes: Array<Tensor>, concat_dim: Long, name: String = "SparseConcat") = run {
  buildOpTensors("SparseConcat", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(shapes, false)
    attr("concat_dim", concat_dim)
  }
}

fun TF.sparseCross(indices: Array<Tensor>, values: Tensor, shapes: Array<Tensor>, dense_inputs: Tensor, hashed_output: Boolean, num_buckets: Long, hash_key: Long, out_type: Int, internal_type: Int, name: String = "SparseCross") = run {
  buildOpTensors("SparseCross", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(shapes, false)
    addInput(dense_inputs, false)
    attr("hashed_output", hashed_output)
    attr("num_buckets", num_buckets)
    attr("hash_key", hash_key)
    attrType("out_type", out_type)
    attrType("internal_type", internal_type)
  }
}

fun TF.sparseDenseCwiseAdd(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, dense: Tensor, name: String = "SparseDenseCwiseAdd") = run {
  buildOpTensor("SparseDenseCwiseAdd", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
    addInput(dense, false)
  }
}

fun TF.sparseDenseCwiseDiv(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, dense: Tensor, name: String = "SparseDenseCwiseDiv") = run {
  buildOpTensor("SparseDenseCwiseDiv", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
    addInput(dense, false)
  }
}

fun TF.sparseDenseCwiseMul(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, dense: Tensor, name: String = "SparseDenseCwiseMul") = run {
  buildOpTensor("SparseDenseCwiseMul", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
    addInput(dense, false)
  }
}

fun TF.sparseFillEmptyRows(indices: Tensor, values: Tensor, dense_shape: Tensor, default_value: Tensor, name: String = "SparseFillEmptyRows") = run {
  buildOpTensors("SparseFillEmptyRows", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(dense_shape, false)
    addInput(default_value, false)
  }
}

fun TF.sparseFillEmptyRowsGrad(reverse_index_map: Tensor, grad_values: Tensor, name: String = "SparseFillEmptyRowsGrad") = run {
  buildOpTensors("SparseFillEmptyRowsGrad", name) {
    addInput(reverse_index_map, false)
    addInput(grad_values, false)
  }
}

fun TF.sparseReduceMax(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceMax") = run {
  buildOpTensor("SparseReduceMax", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReduceMaxSparse(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceMaxSparse") = run {
  buildOpTensors("SparseReduceMaxSparse", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReduceSum(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceSum") = run {
  buildOpTensor("SparseReduceSum", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReduceSumSparse(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceSumSparse") = run {
  buildOpTensors("SparseReduceSumSparse", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReorder(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, name: String = "SparseReorder") = run {
  buildOpTensors("SparseReorder", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
  }
}

fun TF.sparseReshape(input_indices: Tensor, input_shape: Tensor, new_shape: Tensor, name: String = "SparseReshape") = run {
  buildOpTensors("SparseReshape", name) {
    addInput(input_indices, false)
    addInput(input_shape, false)
    addInput(new_shape, false)
  }
}

fun TF.sparseSlice(indices: Tensor, values: Tensor, shape: Tensor, start: Tensor, size: Tensor, name: String = "SparseSlice") = run {
  buildOpTensors("SparseSlice", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(shape, false)
    addInput(start, false)
    addInput(size, false)
  }
}

fun TF.sparseSliceGrad(backprop_val_grad: Tensor, input_indices: Tensor, input_start: Tensor, output_indices: Tensor, name: String = "SparseSliceGrad") = run {
  buildOpTensor("SparseSliceGrad", name) {
    addInput(backprop_val_grad, false)
    addInput(input_indices, false)
    addInput(input_start, false)
    addInput(output_indices, false)
  }
}

fun TF.sparseSoftmax(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, name: String = "SparseSoftmax") = run {
  buildOpTensor("SparseSoftmax", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
  }
}

fun TF.sparseSparseMaximum(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b_indices: Tensor, b_values: Tensor, b_shape: Tensor, name: String = "SparseSparseMaximum") = run {
  buildOpTensors("SparseSparseMaximum", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b_indices, false)
    addInput(b_values, false)
    addInput(b_shape, false)
  }
}

fun TF.sparseSparseMinimum(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b_indices: Tensor, b_values: Tensor, b_shape: Tensor, name: String = "SparseSparseMinimum") = run {
  buildOpTensors("SparseSparseMinimum", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b_indices, false)
    addInput(b_values, false)
    addInput(b_shape, false)
  }
}

fun TF.sparseSplit(split_dim: Tensor, indices: Tensor, values: Tensor, shape: Tensor, num_split: Long, name: String = "SparseSplit") = run {
  buildOpTensors("SparseSplit", name) {
    addInput(split_dim, false)
    addInput(indices, false)
    addInput(values, false)
    addInput(shape, false)
    attr("num_split", num_split)
  }
}

fun TF.sparseTensorDenseAdd(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b: Tensor, name: String = "SparseTensorDenseAdd") = run {
  buildOpTensor("SparseTensorDenseAdd", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b, false)
  }
}

fun TF.sparseTensorDenseMatMul(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b: Tensor, adjoint_a: Boolean = false, adjoint_b: Boolean = false, name: String = "SparseTensorDenseMatMul") = run {
  buildOpTensor("SparseTensorDenseMatMul", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b, false)
    attr("adjoint_a", adjoint_a)
    attr("adjoint_b", adjoint_b)
  }
}

fun TF.sparseToDense(sparse_indices: Tensor, output_shape: Tensor, sparse_values: Tensor, default_value: Tensor, validate_indices: Boolean = true, name: String = "SparseToDense") = run {
  buildOpTensor("SparseToDense", name) {
    addInput(sparse_indices, false)
    addInput(output_shape, false)
    addInput(sparse_values, false)
    addInput(default_value, false)
    attr("validate_indices", validate_indices)
  }
}

fun TF.takeManySparseFromTensorsMap(sparse_handles: Tensor, dtype: Int, container: String = "", shared_name: String = "", name: String = "TakeManySparseFromTensorsMap") = run {
  buildOpTensors("TakeManySparseFromTensorsMap", name) {
    addInput(sparse_handles, false)
    attrType("dtype", dtype)
    attr("container", container)
    attr("shared_name", shared_name)
  }
}
