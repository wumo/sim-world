/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import wumo.sim.algorithm.tensorflow.Tensor
import wumo.sim.algorithm.tensorflow.buildOpTensor
import wumo.sim.algorithm.tensorflow.buildOpTensors
import wumo.sim.algorithm.tensorflow.tf

object gen_sparse_ops {
  fun addManySparseToTensorsMap(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, container: String = "", shared_name: String = "", name: String = "AddManySparseToTensorsMap") = run {
    tf.buildOpTensor("AddManySparseToTensorsMap", name) {
      addInput(sparse_indices, false)
      addInput(sparse_values, false)
      addInput(sparse_shape, false)
      attr("container", container)
      attr("shared_name", shared_name)
    }
  }
  
  fun addSparseToTensorsMap(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, container: String = "", shared_name: String = "", name: String = "AddSparseToTensorsMap") = run {
    tf.buildOpTensor("AddSparseToTensorsMap", name) {
      addInput(sparse_indices, false)
      addInput(sparse_values, false)
      addInput(sparse_shape, false)
      attr("container", container)
      attr("shared_name", shared_name)
    }
  }
  
  fun deserializeManySparse(serialized_sparse: Tensor, dtype: Int, name: String = "DeserializeManySparse") = run {
    tf.buildOpTensors("DeserializeManySparse", name) {
      addInput(serialized_sparse, false)
      attrType("dtype", dtype)
    }
  }
  
  fun deserializeSparse(serialized_sparse: Tensor, dtype: Int, name: String = "DeserializeSparse") = run {
    tf.buildOpTensors("DeserializeSparse", name) {
      addInput(serialized_sparse, false)
      attrType("dtype", dtype)
    }
  }
  
  fun serializeManySparse(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, out_type: Int = 7, name: String = "SerializeManySparse") = run {
    tf.buildOpTensor("SerializeManySparse", name) {
      addInput(sparse_indices, false)
      addInput(sparse_values, false)
      addInput(sparse_shape, false)
      attrType("out_type", out_type)
    }
  }
  
  fun serializeSparse(sparse_indices: Tensor, sparse_values: Tensor, sparse_shape: Tensor, out_type: Int = 7, name: String = "SerializeSparse") = run {
    tf.buildOpTensor("SerializeSparse", name) {
      addInput(sparse_indices, false)
      addInput(sparse_values, false)
      addInput(sparse_shape, false)
      attrType("out_type", out_type)
    }
  }
  
  fun sparseAdd(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b_indices: Tensor, b_values: Tensor, b_shape: Tensor, thresh: Tensor, name: String = "SparseAdd") = run {
    tf.buildOpTensors("SparseAdd", name) {
      addInput(a_indices, false)
      addInput(a_values, false)
      addInput(a_shape, false)
      addInput(b_indices, false)
      addInput(b_values, false)
      addInput(b_shape, false)
      addInput(thresh, false)
    }
  }
  
  fun sparseAddGrad(backprop_val_grad: Tensor, a_indices: Tensor, b_indices: Tensor, sum_indices: Tensor, name: String = "SparseAddGrad") = run {
    tf.buildOpTensors("SparseAddGrad", name) {
      addInput(backprop_val_grad, false)
      addInput(a_indices, false)
      addInput(b_indices, false)
      addInput(sum_indices, false)
    }
  }
  
  fun sparseConcat(indices: Array<Tensor>, values: Array<Tensor>, shapes: Array<Tensor>, concat_dim: Long, name: String = "SparseConcat") = run {
    tf.buildOpTensors("SparseConcat", name) {
      addInput(indices, false)
      addInput(values, false)
      addInput(shapes, false)
      attr("concat_dim", concat_dim)
    }
  }
  
  fun sparseCross(indices: Array<Tensor>, values: Tensor, shapes: Array<Tensor>, dense_inputs: Tensor, hashed_output: Boolean, num_buckets: Long, hash_key: Long, out_type: Int, internal_type: Int, name: String = "SparseCross") = run {
    tf.buildOpTensors("SparseCross", name) {
      addInput(indices, false)
      addInput(values, false)
      addInput(shapes, false)
      addInput(dense_inputs, false)
      attr("hashed_output", hashed_output)
      attr("num_buckets", num_buckets)
      attr("hash_key", hash_key)
      attrType("out_type", out_type)
      attrType("internal_type", internal_type)
    }
  }
  
  fun sparseDenseCwiseAdd(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, dense: Tensor, name: String = "SparseDenseCwiseAdd") = run {
    tf.buildOpTensor("SparseDenseCwiseAdd", name) {
      addInput(sp_indices, false)
      addInput(sp_values, false)
      addInput(sp_shape, false)
      addInput(dense, false)
    }
  }
  
  fun sparseDenseCwiseDiv(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, dense: Tensor, name: String = "SparseDenseCwiseDiv") = run {
    tf.buildOpTensor("SparseDenseCwiseDiv", name) {
      addInput(sp_indices, false)
      addInput(sp_values, false)
      addInput(sp_shape, false)
      addInput(dense, false)
    }
  }
  
  fun sparseDenseCwiseMul(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, dense: Tensor, name: String = "SparseDenseCwiseMul") = run {
    tf.buildOpTensor("SparseDenseCwiseMul", name) {
      addInput(sp_indices, false)
      addInput(sp_values, false)
      addInput(sp_shape, false)
      addInput(dense, false)
    }
  }
  
  fun sparseFillEmptyRows(indices: Tensor, values: Tensor, dense_shape: Tensor, default_value: Tensor, name: String = "SparseFillEmptyRows") = run {
    tf.buildOpTensors("SparseFillEmptyRows", name) {
      addInput(indices, false)
      addInput(values, false)
      addInput(dense_shape, false)
      addInput(default_value, false)
    }
  }
  
  fun sparseFillEmptyRowsGrad(reverse_index_map: Tensor, grad_values: Tensor, name: String = "SparseFillEmptyRowsGrad") = run {
    tf.buildOpTensors("SparseFillEmptyRowsGrad", name) {
      addInput(reverse_index_map, false)
      addInput(grad_values, false)
    }
  }
  
  fun sparseReduceMax(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceMax") = run {
    tf.buildOpTensor("SparseReduceMax", name) {
      addInput(input_indices, false)
      addInput(input_values, false)
      addInput(input_shape, false)
      addInput(reduction_axes, false)
      attr("keep_dims", keep_dims)
    }
  }
  
  fun sparseReduceMaxSparse(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceMaxSparse") = run {
    tf.buildOpTensors("SparseReduceMaxSparse", name) {
      addInput(input_indices, false)
      addInput(input_values, false)
      addInput(input_shape, false)
      addInput(reduction_axes, false)
      attr("keep_dims", keep_dims)
    }
  }
  
  fun sparseReduceSum(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceSum") = run {
    tf.buildOpTensor("SparseReduceSum", name) {
      addInput(input_indices, false)
      addInput(input_values, false)
      addInput(input_shape, false)
      addInput(reduction_axes, false)
      attr("keep_dims", keep_dims)
    }
  }
  
  fun sparseReduceSumSparse(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, reduction_axes: Tensor, keep_dims: Boolean = false, name: String = "SparseReduceSumSparse") = run {
    tf.buildOpTensors("SparseReduceSumSparse", name) {
      addInput(input_indices, false)
      addInput(input_values, false)
      addInput(input_shape, false)
      addInput(reduction_axes, false)
      attr("keep_dims", keep_dims)
    }
  }
  
  fun sparseReorder(input_indices: Tensor, input_values: Tensor, input_shape: Tensor, name: String = "SparseReorder") = run {
    tf.buildOpTensors("SparseReorder", name) {
      addInput(input_indices, false)
      addInput(input_values, false)
      addInput(input_shape, false)
    }
  }
  
  fun sparseReshape(input_indices: Tensor, input_shape: Tensor, new_shape: Tensor, name: String = "SparseReshape") = run {
    tf.buildOpTensors("SparseReshape", name) {
      addInput(input_indices, false)
      addInput(input_shape, false)
      addInput(new_shape, false)
    }
  }
  
  fun sparseSlice(indices: Tensor, values: Tensor, shape: Tensor, start: Tensor, size: Tensor, name: String = "SparseSlice") = run {
    tf.buildOpTensors("SparseSlice", name) {
      addInput(indices, false)
      addInput(values, false)
      addInput(shape, false)
      addInput(start, false)
      addInput(size, false)
    }
  }
  
  fun sparseSliceGrad(backprop_val_grad: Tensor, input_indices: Tensor, input_start: Tensor, output_indices: Tensor, name: String = "SparseSliceGrad") = run {
    tf.buildOpTensor("SparseSliceGrad", name) {
      addInput(backprop_val_grad, false)
      addInput(input_indices, false)
      addInput(input_start, false)
      addInput(output_indices, false)
    }
  }
  
  fun sparseSoftmax(sp_indices: Tensor, sp_values: Tensor, sp_shape: Tensor, name: String = "SparseSoftmax") = run {
    tf.buildOpTensor("SparseSoftmax", name) {
      addInput(sp_indices, false)
      addInput(sp_values, false)
      addInput(sp_shape, false)
    }
  }
  
  fun sparseSparseMaximum(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b_indices: Tensor, b_values: Tensor, b_shape: Tensor, name: String = "SparseSparseMaximum") = run {
    tf.buildOpTensors("SparseSparseMaximum", name) {
      addInput(a_indices, false)
      addInput(a_values, false)
      addInput(a_shape, false)
      addInput(b_indices, false)
      addInput(b_values, false)
      addInput(b_shape, false)
    }
  }
  
  fun sparseSparseMinimum(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b_indices: Tensor, b_values: Tensor, b_shape: Tensor, name: String = "SparseSparseMinimum") = run {
    tf.buildOpTensors("SparseSparseMinimum", name) {
      addInput(a_indices, false)
      addInput(a_values, false)
      addInput(a_shape, false)
      addInput(b_indices, false)
      addInput(b_values, false)
      addInput(b_shape, false)
    }
  }
  
  fun sparseSplit(split_dim: Tensor, indices: Tensor, values: Tensor, shape: Tensor, num_split: Long, name: String = "SparseSplit") = run {
    tf.buildOpTensors("SparseSplit", name) {
      addInput(split_dim, false)
      addInput(indices, false)
      addInput(values, false)
      addInput(shape, false)
      attr("num_split", num_split)
    }
  }
  
  fun sparseTensorDenseAdd(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b: Tensor, name: String = "SparseTensorDenseAdd") = run {
    tf.buildOpTensor("SparseTensorDenseAdd", name) {
      addInput(a_indices, false)
      addInput(a_values, false)
      addInput(a_shape, false)
      addInput(b, false)
    }
  }
  
  fun sparseTensorDenseMatMul(a_indices: Tensor, a_values: Tensor, a_shape: Tensor, b: Tensor, adjoint_a: Boolean = false, adjoint_b: Boolean = false, name: String = "SparseTensorDenseMatMul") = run {
    tf.buildOpTensor("SparseTensorDenseMatMul", name) {
      addInput(a_indices, false)
      addInput(a_values, false)
      addInput(a_shape, false)
      addInput(b, false)
      attr("adjoint_a", adjoint_a)
      attr("adjoint_b", adjoint_b)
    }
  }
  
  fun sparseToDense(sparse_indices: Tensor, output_shape: Tensor, sparse_values: Tensor, default_value: Tensor, validate_indices: Boolean = true, name: String = "SparseToDense") = run {
    tf.buildOpTensor("SparseToDense", name) {
      addInput(sparse_indices, false)
      addInput(output_shape, false)
      addInput(sparse_values, false)
      addInput(default_value, false)
      attr("validate_indices", validate_indices)
    }
  }
  
  fun takeManySparseFromTensorsMap(sparse_handles: Tensor, dtype: Int, container: String = "", shared_name: String = "", name: String = "TakeManySparseFromTensorsMap") = run {
    tf.buildOpTensors("TakeManySparseFromTensorsMap", name) {
      addInput(sparse_handles, false)
      attrType("dtype", dtype)
      attr("container", container)
      attr("shared_name", shared_name)
    }
  }
}