/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import org.bytedeco.javacpp.tensorflow.DT_STRING
import wumo.sim.algorithm.tensorflow.TF
import wumo.sim.algorithm.tensorflow.ops.Output
import wumo.sim.algorithm.tensorflow.buildOpTensor
import wumo.sim.algorithm.tensorflow.buildOpTensors

fun TF.addManySparseToTensorsMap(sparse_indices: Output, sparse_values: Output, sparse_shape: Output, container: String = "", shared_name: String = "", name: String = "AddManySparseToTensorsMap") = run {
  buildOpTensor("AddManySparseToTensorsMap", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attr("container", container)
    attr("shared_name", shared_name)
  }
}

fun TF.addSparseToTensorsMap(sparse_indices: Output, sparse_values: Output, sparse_shape: Output, container: String = "", shared_name: String = "", name: String = "AddSparseToTensorsMap") = run {
  buildOpTensor("AddSparseToTensorsMap", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attr("container", container)
    attr("shared_name", shared_name)
  }
}

fun TF.deserializeManySparse(serialized_sparse: Output, dtype: Int, name: String = "DeserializeManySparse") = run {
  buildOpTensors("DeserializeManySparse", name) {
    addInput(serialized_sparse, false)
    attrType("dtype", dtype)
  }
}

fun TF.deserializeSparse(serialized_sparse: Output, dtype: Int, name: String = "DeserializeSparse") = run {
  buildOpTensors("DeserializeSparse", name) {
    addInput(serialized_sparse, false)
    attrType("dtype", dtype)
  }
}

fun TF.serializeManySparse(sparse_indices: Output, sparse_values: Output, sparse_shape: Output, out_type: Int = DT_STRING, name: String = "SerializeManySparse") = run {
  buildOpTensor("SerializeManySparse", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attrType("out_type", out_type)
  }
}

fun TF.serializeSparse(sparse_indices: Output, sparse_values: Output, sparse_shape: Output, out_type: Int = DT_STRING, name: String = "SerializeSparse") = run {
  buildOpTensor("SerializeSparse", name) {
    addInput(sparse_indices, false)
    addInput(sparse_values, false)
    addInput(sparse_shape, false)
    attrType("out_type", out_type)
  }
}

fun TF.sparseAdd(a_indices: Output, a_values: Output, a_shape: Output, b_indices: Output, b_values: Output, b_shape: Output, thresh: Output, name: String = "SparseAdd") = run {
  buildOpTensors("SparseAdd", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b_indices, false)
    addInput(b_values, false)
    addInput(b_shape, false)
    addInput(thresh, false)
  }
}

fun TF.sparseAddGrad(backprop_val_grad: Output, a_indices: Output, b_indices: Output, sum_indices: Output, name: String = "SparseAddGrad") = run {
  buildOpTensors("SparseAddGrad", name) {
    addInput(backprop_val_grad, false)
    addInput(a_indices, false)
    addInput(b_indices, false)
    addInput(sum_indices, false)
  }
}

fun TF.sparseConcat(indices: Array<Output>, values: Array<Output>, shapes: Array<Output>, concat_dim: Long, name: String = "SparseConcat") = run {
  buildOpTensors("SparseConcat", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(shapes, false)
    attr("concat_dim", concat_dim)
  }
}

fun TF.sparseCross(indices: Array<Output>, values: Output, shapes: Array<Output>, dense_inputs: Output, hashed_output: Boolean, num_buckets: Long, hash_key: Long, out_type: Int, internal_type: Int, name: String = "SparseCross") = run {
  buildOpTensors("SparseCross", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(shapes, false)
    addInput(dense_inputs, false)
    attr("hashed_output", hashed_output)
    attr("num_buckets", num_buckets)
    attr("hash_key", hash_key)
    attrType("out_type", out_type)
    attrType("internal_type", internal_type)
  }
}

fun TF.sparseDenseCwiseAdd(sp_indices: Output, sp_values: Output, sp_shape: Output, dense: Output, name: String = "SparseDenseCwiseAdd") = run {
  buildOpTensor("SparseDenseCwiseAdd", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
    addInput(dense, false)
  }
}

fun TF.sparseDenseCwiseDiv(sp_indices: Output, sp_values: Output, sp_shape: Output, dense: Output, name: String = "SparseDenseCwiseDiv") = run {
  buildOpTensor("SparseDenseCwiseDiv", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
    addInput(dense, false)
  }
}

fun TF.sparseDenseCwiseMul(sp_indices: Output, sp_values: Output, sp_shape: Output, dense: Output, name: String = "SparseDenseCwiseMul") = run {
  buildOpTensor("SparseDenseCwiseMul", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
    addInput(dense, false)
  }
}

fun TF.sparseFillEmptyRows(indices: Output, values: Output, dense_shape: Output, default_value: Output, name: String = "SparseFillEmptyRows") = run {
  buildOpTensors("SparseFillEmptyRows", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(dense_shape, false)
    addInput(default_value, false)
  }
}

fun TF.sparseFillEmptyRowsGrad(reverse_index_map: Output, grad_values: Output, name: String = "SparseFillEmptyRowsGrad") = run {
  buildOpTensors("SparseFillEmptyRowsGrad", name) {
    addInput(reverse_index_map, false)
    addInput(grad_values, false)
  }
}

fun TF.sparseReduceMax(input_indices: Output, input_values: Output, input_shape: Output, reduction_axes: Output, keep_dims: Boolean = false, name: String = "SparseReduceMax") = run {
  buildOpTensor("SparseReduceMax", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReduceMaxSparse(input_indices: Output, input_values: Output, input_shape: Output, reduction_axes: Output, keep_dims: Boolean = false, name: String = "SparseReduceMaxSparse") = run {
  buildOpTensors("SparseReduceMaxSparse", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReduceSum(input_indices: Output, input_values: Output, input_shape: Output, reduction_axes: Output, keep_dims: Boolean = false, name: String = "SparseReduceSum") = run {
  buildOpTensor("SparseReduceSum", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReduceSumSparse(input_indices: Output, input_values: Output, input_shape: Output, reduction_axes: Output, keep_dims: Boolean = false, name: String = "SparseReduceSumSparse") = run {
  buildOpTensors("SparseReduceSumSparse", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
    addInput(reduction_axes, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.sparseReorder(input_indices: Output, input_values: Output, input_shape: Output, name: String = "SparseReorder") = run {
  buildOpTensors("SparseReorder", name) {
    addInput(input_indices, false)
    addInput(input_values, false)
    addInput(input_shape, false)
  }
}

fun TF.sparseReshape(input_indices: Output, input_shape: Output, new_shape: Output, name: String = "SparseReshape") = run {
  buildOpTensors("SparseReshape", name) {
    addInput(input_indices, false)
    addInput(input_shape, false)
    addInput(new_shape, false)
  }
}

fun TF.sparseSlice(indices: Output, values: Output, shape: Output, start: Output, size: Output, name: String = "SparseSlice") = run {
  buildOpTensors("SparseSlice", name) {
    addInput(indices, false)
    addInput(values, false)
    addInput(shape, false)
    addInput(start, false)
    addInput(size, false)
  }
}

fun TF.sparseSliceGrad(backprop_val_grad: Output, input_indices: Output, input_start: Output, output_indices: Output, name: String = "SparseSliceGrad") = run {
  buildOpTensor("SparseSliceGrad", name) {
    addInput(backprop_val_grad, false)
    addInput(input_indices, false)
    addInput(input_start, false)
    addInput(output_indices, false)
  }
}

fun TF.sparseSoftmax(sp_indices: Output, sp_values: Output, sp_shape: Output, name: String = "SparseSoftmax") = run {
  buildOpTensor("SparseSoftmax", name) {
    addInput(sp_indices, false)
    addInput(sp_values, false)
    addInput(sp_shape, false)
  }
}

fun TF.sparseSparseMaximum(a_indices: Output, a_values: Output, a_shape: Output, b_indices: Output, b_values: Output, b_shape: Output, name: String = "SparseSparseMaximum") = run {
  buildOpTensors("SparseSparseMaximum", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b_indices, false)
    addInput(b_values, false)
    addInput(b_shape, false)
  }
}

fun TF.sparseSparseMinimum(a_indices: Output, a_values: Output, a_shape: Output, b_indices: Output, b_values: Output, b_shape: Output, name: String = "SparseSparseMinimum") = run {
  buildOpTensors("SparseSparseMinimum", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b_indices, false)
    addInput(b_values, false)
    addInput(b_shape, false)
  }
}

fun TF.sparseSplit(split_dim: Output, indices: Output, values: Output, shape: Output, num_split: Long, name: String = "SparseSplit") = run {
  buildOpTensors("SparseSplit", name) {
    addInput(split_dim, false)
    addInput(indices, false)
    addInput(values, false)
    addInput(shape, false)
    attr("num_split", num_split)
  }
}

fun TF.sparseTensorDenseAdd(a_indices: Output, a_values: Output, a_shape: Output, b: Output, name: String = "SparseTensorDenseAdd") = run {
  buildOpTensor("SparseTensorDenseAdd", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b, false)
  }
}

fun TF.sparseTensorDenseMatMul(a_indices: Output, a_values: Output, a_shape: Output, b: Output, adjoint_a: Boolean = false, adjoint_b: Boolean = false, name: String = "SparseTensorDenseMatMul") = run {
  buildOpTensor("SparseTensorDenseMatMul", name) {
    addInput(a_indices, false)
    addInput(a_values, false)
    addInput(a_shape, false)
    addInput(b, false)
    attr("adjoint_a", adjoint_a)
    attr("adjoint_b", adjoint_b)
  }
}

fun TF.sparseToDense(sparse_indices: Output, output_shape: Output, sparse_values: Output, default_value: Output, validate_indices: Boolean = true, name: String = "SparseToDense") = run {
  buildOpTensor("SparseToDense", name) {
    addInput(sparse_indices, false)
    addInput(output_shape, false)
    addInput(sparse_values, false)
    addInput(default_value, false)
    attr("validate_indices", validate_indices)
  }
}

fun TF.takeManySparseFromTensorsMap(sparse_handles: Output, dtype: Int, container: String = "", shared_name: String = "", name: String = "TakeManySparseFromTensorsMap") = run {
  buildOpTensors("TakeManySparseFromTensorsMap", name) {
    addInput(sparse_handles, false)
    attrType("dtype", dtype)
    attr("container", container)
    attr("shared_name", shared_name)
  }
}
