/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import wumo.sim.algorithm.tensorflow.*

object gen_control_flow_ops {
  fun abort(error_msg: String = "", exit_without_error: Boolean = false, name: String = "Abort") = run {
    tf.buildOp("Abort", name) {
      attr("error_msg", error_msg)
      attr("exit_without_error", exit_without_error)
    }
  }
  
  fun controlTrigger(name: String = "ControlTrigger") = run {
    tf.buildOp("ControlTrigger", name) {
    }
  }
  
  fun loopCond(input: Tensor, name: String = "LoopCond") = run {
    tf.buildOpTensor("LoopCond", name) {
      addInput(input, false)
    }
  }
  
  fun merge(inputs: Array<Tensor>, name: String = "Merge") = run {
    tf.buildOpTensors("Merge", name) {
      addInput(inputs, false)
    }
  }
  
  fun nextIteration(data: Tensor, name: String = "NextIteration") = run {
    tf.buildOpTensor("NextIteration", name) {
      addInput(data, false)
    }
  }
  
  fun refNextIteration(data: Tensor, name: String = "RefNextIteration") = run {
    tf.buildOpTensor("RefNextIteration", name) {
      addInput(data, true)
    }
  }
  
  fun refSelect(index: Tensor, inputs: Array<Tensor>, name: String = "RefSelect") = run {
    tf.buildOpTensor("RefSelect", name) {
      addInput(index, false)
      addInput(inputs, true)
    }
  }
  
  fun refSwitch(data: Tensor, pred: Tensor, name: String = "RefSwitch") = run {
    tf.buildOpTensors("RefSwitch", name) {
      addInput(data, true)
      addInput(pred, false)
    }
  }
  
  fun switch(data: Tensor, pred: Tensor, name: String = "Switch") = run {
    tf.buildOpTensors("Switch", name) {
      addInput(data, false)
      addInput(pred, false)
    }
  }
  
  fun enter(data: Tensor, frame_name: String, is_constant: Boolean = false, parallel_iterations: Long = 10L, name: String = "Enter") = run {
    tf.buildOpTensor("Enter", name) {
      addInput(data, false)
      attr("frame_name", frame_name)
      attr("is_constant", is_constant)
      attr("parallel_iterations", parallel_iterations)
    }
  }
  
  fun exit(data: Tensor, name: String = "Exit") = run {
    tf.buildOpTensor("Exit", name) {
      addInput(data, false)
    }
  }
  
  fun refEnter(data: Tensor, frame_name: String, is_constant: Boolean = false, parallel_iterations: Long = 10L, name: String = "RefEnter") = run {
    tf.buildOpTensor("RefEnter", name) {
      addInput(data, true)
      attr("frame_name", frame_name)
      attr("is_constant", is_constant)
      attr("parallel_iterations", parallel_iterations)
    }
  }
  
  fun refExit(data: Tensor, name: String = "RefExit") = run {
    tf.buildOpTensor("RefExit", name) {
      addInput(data, true)
    }
  }
  
  fun refMerge(inputs: Array<Tensor>, name: String = "RefMerge") = run {
    tf.buildOpTensors("RefMerge", name) {
      addInput(inputs, true)
    }
  }
}