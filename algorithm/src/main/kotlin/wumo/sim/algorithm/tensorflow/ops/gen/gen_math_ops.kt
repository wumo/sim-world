/**
 * DO NOT EDIT THIS FILE - it is machine generated
 */
package wumo.sim.algorithm.tensorflow.ops.gen

import org.bytedeco.javacpp.tensorflow.*
import wumo.sim.algorithm.tensorflow.TF
import wumo.sim.algorithm.tensorflow.Tensor
import wumo.sim.algorithm.tensorflow.buildOpTensor
import wumo.sim.algorithm.tensorflow.buildOpTensors
import wumo.sim.util.Dimension

fun TF.abs(x: Tensor, name: String = "Abs") = run {
  buildOpTensor("Abs", name) {
    addInput(x, false)
  }
}

fun TF.accumulateNV2(inputs: Array<Tensor>, shape: Dimension, name: String = "AccumulateNV2") = run {
  buildOpTensor("AccumulateNV2", name) {
    addInput(inputs, false)
    attr("shape", shape)
  }
}

fun TF.acos(x: Tensor, name: String = "Acos") = run {
  buildOpTensor("Acos", name) {
    addInput(x, false)
  }
}

fun TF.acosh(x: Tensor, name: String = "Acosh") = run {
  buildOpTensor("Acosh", name) {
    addInput(x, false)
  }
}

fun TF.add(x: Tensor, y: Tensor, name: String = "Add") = run {
  buildOpTensor("Add", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.addN(inputs: Array<Tensor>, name: String = "AddN") = run {
  buildOpTensor("AddN", name) {
    addInput(inputs, false)
  }
}

fun TF.addV2(x: Tensor, y: Tensor, name: String = "AddV2") = run {
  buildOpTensor("AddV2", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.all(input: Tensor, reduction_indices: Tensor, keep_dims: Boolean = false, name: String = "All") = run {
  buildOpTensor("All", name) {
    addInput(input, false)
    addInput(reduction_indices, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.angle(input: Tensor, tout: Int = DT_FLOAT, name: String = "Angle") = run {
  buildOpTensor("Angle", name) {
    addInput(input, false)
    attrType("Tout", tout)
  }
}

fun TF.any(input: Tensor, reduction_indices: Tensor, keep_dims: Boolean = false, name: String = "Any") = run {
  buildOpTensor("Any", name) {
    addInput(input, false)
    addInput(reduction_indices, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.approximateEqual(x: Tensor, y: Tensor, tolerance: Float = 1.0E-5f, name: String = "ApproximateEqual") = run {
  buildOpTensor("ApproximateEqual", name) {
    addInput(x, false)
    addInput(y, false)
    attr("tolerance", tolerance)
  }
}

fun TF.argMax(input: Tensor, dimension: Tensor, output_type: Int = DT_INT64, name: String = "ArgMax") = run {
  buildOpTensor("ArgMax", name) {
    addInput(input, false)
    addInput(dimension, false)
    attrType("output_type", output_type)
  }
}

fun TF.argMin(input: Tensor, dimension: Tensor, output_type: Int = DT_INT64, name: String = "ArgMin") = run {
  buildOpTensor("ArgMin", name) {
    addInput(input, false)
    addInput(dimension, false)
    attrType("output_type", output_type)
  }
}

fun TF.asin(x: Tensor, name: String = "Asin") = run {
  buildOpTensor("Asin", name) {
    addInput(x, false)
  }
}

fun TF.asinh(x: Tensor, name: String = "Asinh") = run {
  buildOpTensor("Asinh", name) {
    addInput(x, false)
  }
}

fun TF.atan(x: Tensor, name: String = "Atan") = run {
  buildOpTensor("Atan", name) {
    addInput(x, false)
  }
}

fun TF.atan2(y: Tensor, x: Tensor, name: String = "Atan2") = run {
  buildOpTensor("Atan2", name) {
    addInput(y, false)
    addInput(x, false)
  }
}

fun TF.atanh(x: Tensor, name: String = "Atanh") = run {
  buildOpTensor("Atanh", name) {
    addInput(x, false)
  }
}

fun TF.batchMatMul(x: Tensor, y: Tensor, adj_x: Boolean = false, adj_y: Boolean = false, name: String = "BatchMatMul") = run {
  buildOpTensor("BatchMatMul", name) {
    addInput(x, false)
    addInput(y, false)
    attr("adj_x", adj_x)
    attr("adj_y", adj_y)
  }
}

fun TF.besselI0e(x: Tensor, name: String = "BesselI0e") = run {
  buildOpTensor("BesselI0e", name) {
    addInput(x, false)
  }
}

fun TF.besselI1e(x: Tensor, name: String = "BesselI1e") = run {
  buildOpTensor("BesselI1e", name) {
    addInput(x, false)
  }
}

fun TF.betainc(a: Tensor, b: Tensor, x: Tensor, name: String = "Betainc") = run {
  buildOpTensor("Betainc", name) {
    addInput(a, false)
    addInput(b, false)
    addInput(x, false)
  }
}

fun TF.bincount(arr: Tensor, size: Tensor, weights: Tensor, name: String = "Bincount") = run {
  buildOpTensor("Bincount", name) {
    addInput(arr, false)
    addInput(size, false)
    addInput(weights, false)
  }
}

fun TF.bucketize(input: Tensor, boundaries: Array<Float>, name: String = "Bucketize") = run {
  buildOpTensor("Bucketize", name) {
    addInput(input, false)
    attr("boundaries", boundaries)
  }
}

fun TF.cast(x: Tensor, dstT: Int, name: String = "Cast") = run {
  buildOpTensor("Cast", name) {
    addInput(x, false)
    attrType("DstT", dstT)
  }
}

fun TF.ceil(x: Tensor, name: String = "Ceil") = run {
  buildOpTensor("Ceil", name) {
    addInput(x, false)
  }
}

fun TF.clipByValue(t: Tensor, clip_value_min: Tensor, clip_value_max: Tensor, name: String = "ClipByValue") = run {
  buildOpTensor("ClipByValue", name) {
    addInput(t, false)
    addInput(clip_value_min, false)
    addInput(clip_value_max, false)
  }
}

fun TF.compareAndBitpack(input: Tensor, threshold: Tensor, name: String = "CompareAndBitpack") = run {
  buildOpTensor("CompareAndBitpack", name) {
    addInput(input, false)
    addInput(threshold, false)
  }
}

fun TF.complex(real: Tensor, imag: Tensor, tout: Int = DT_COMPLEX64, name: String = "Complex") = run {
  buildOpTensor("Complex", name) {
    addInput(real, false)
    addInput(imag, false)
    attrType("Tout", tout)
  }
}

fun TF.complexAbs(x: Tensor, tout: Int = DT_FLOAT, name: String = "ComplexAbs") = run {
  buildOpTensor("ComplexAbs", name) {
    addInput(x, false)
    attrType("Tout", tout)
  }
}

fun TF.conj(input: Tensor, name: String = "Conj") = run {
  buildOpTensor("Conj", name) {
    addInput(input, false)
  }
}

fun TF.cos(x: Tensor, name: String = "Cos") = run {
  buildOpTensor("Cos", name) {
    addInput(x, false)
  }
}

fun TF.cosh(x: Tensor, name: String = "Cosh") = run {
  buildOpTensor("Cosh", name) {
    addInput(x, false)
  }
}

fun TF.cross(a: Tensor, b: Tensor, name: String = "Cross") = run {
  buildOpTensor("Cross", name) {
    addInput(a, false)
    addInput(b, false)
  }
}

fun TF.cumprod(x: Tensor, axis: Tensor, exclusive: Boolean = false, reverse: Boolean = false, name: String = "Cumprod") = run {
  buildOpTensor("Cumprod", name) {
    addInput(x, false)
    addInput(axis, false)
    attr("exclusive", exclusive)
    attr("reverse", reverse)
  }
}

fun TF.cumsum(x: Tensor, axis: Tensor, exclusive: Boolean = false, reverse: Boolean = false, name: String = "Cumsum") = run {
  buildOpTensor("Cumsum", name) {
    addInput(x, false)
    addInput(axis, false)
    attr("exclusive", exclusive)
    attr("reverse", reverse)
  }
}

fun TF.digamma(x: Tensor, name: String = "Digamma") = run {
  buildOpTensor("Digamma", name) {
    addInput(x, false)
  }
}

fun TF.div(x: Tensor, y: Tensor, name: String = "Div") = run {
  buildOpTensor("Div", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.equal(x: Tensor, y: Tensor, name: String = "Equal") = run {
  buildOpTensor("Equal", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.erf(x: Tensor, name: String = "Erf") = run {
  buildOpTensor("Erf", name) {
    addInput(x, false)
  }
}

fun TF.erfc(x: Tensor, name: String = "Erfc") = run {
  buildOpTensor("Erfc", name) {
    addInput(x, false)
  }
}

fun TF.exp(x: Tensor, name: String = "Exp") = run {
  buildOpTensor("Exp", name) {
    addInput(x, false)
  }
}

fun TF.expm1(x: Tensor, name: String = "Expm1") = run {
  buildOpTensor("Expm1", name) {
    addInput(x, false)
  }
}

fun TF.floor(x: Tensor, name: String = "Floor") = run {
  buildOpTensor("Floor", name) {
    addInput(x, false)
  }
}

fun TF.floorDiv(x: Tensor, y: Tensor, name: String = "FloorDiv") = run {
  buildOpTensor("FloorDiv", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.floorMod(x: Tensor, y: Tensor, name: String = "FloorMod") = run {
  buildOpTensor("FloorMod", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.greater(x: Tensor, y: Tensor, name: String = "Greater") = run {
  buildOpTensor("Greater", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.greaterEqual(x: Tensor, y: Tensor, name: String = "GreaterEqual") = run {
  buildOpTensor("GreaterEqual", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.histogramFixedWidth(values: Tensor, value_range: Tensor, nbins: Tensor, dtype: Int = DT_INT32, name: String = "HistogramFixedWidth") = run {
  buildOpTensor("HistogramFixedWidth", name) {
    addInput(values, false)
    addInput(value_range, false)
    addInput(nbins, false)
    attrType("dtype", dtype)
  }
}

fun TF.igamma(a: Tensor, x: Tensor, name: String = "Igamma") = run {
  buildOpTensor("Igamma", name) {
    addInput(a, false)
    addInput(x, false)
  }
}

fun TF.igammac(a: Tensor, x: Tensor, name: String = "Igammac") = run {
  buildOpTensor("Igammac", name) {
    addInput(a, false)
    addInput(x, false)
  }
}

fun TF.imag(input: Tensor, tout: Int = DT_FLOAT, name: String = "Imag") = run {
  buildOpTensor("Imag", name) {
    addInput(input, false)
    attrType("Tout", tout)
  }
}

fun TF.inv(x: Tensor, name: String = "Inv") = run {
  buildOpTensor("Inv", name) {
    addInput(x, false)
  }
}

fun TF.isFinite(x: Tensor, name: String = "IsFinite") = run {
  buildOpTensor("IsFinite", name) {
    addInput(x, false)
  }
}

fun TF.isInf(x: Tensor, name: String = "IsInf") = run {
  buildOpTensor("IsInf", name) {
    addInput(x, false)
  }
}

fun TF.isNan(x: Tensor, name: String = "IsNan") = run {
  buildOpTensor("IsNan", name) {
    addInput(x, false)
  }
}

fun TF.less(x: Tensor, y: Tensor, name: String = "Less") = run {
  buildOpTensor("Less", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.lessEqual(x: Tensor, y: Tensor, name: String = "LessEqual") = run {
  buildOpTensor("LessEqual", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.lgamma(x: Tensor, name: String = "Lgamma") = run {
  buildOpTensor("Lgamma", name) {
    addInput(x, false)
  }
}

fun TF.linSpace(start: Tensor, stop: Tensor, num: Tensor, name: String = "LinSpace") = run {
  buildOpTensor("LinSpace", name) {
    addInput(start, false)
    addInput(stop, false)
    addInput(num, false)
  }
}

fun TF.log(x: Tensor, name: String = "Log") = run {
  buildOpTensor("Log", name) {
    addInput(x, false)
  }
}

fun TF.log1p(x: Tensor, name: String = "Log1p") = run {
  buildOpTensor("Log1p", name) {
    addInput(x, false)
  }
}

fun TF.logicalAnd(x: Tensor, y: Tensor, name: String = "LogicalAnd") = run {
  buildOpTensor("LogicalAnd", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.logicalNot(x: Tensor, name: String = "LogicalNot") = run {
  buildOpTensor("LogicalNot", name) {
    addInput(x, false)
  }
}

fun TF.logicalOr(x: Tensor, y: Tensor, name: String = "LogicalOr") = run {
  buildOpTensor("LogicalOr", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.matMul(a: Tensor, b: Tensor, transpose_a: Boolean = false, transpose_b: Boolean = false, name: String = "MatMul") = run {
  buildOpTensor("MatMul", name) {
    addInput(a, false)
    addInput(b, false)
    attr("transpose_a", transpose_a)
    attr("transpose_b", transpose_b)
  }
}

fun TF.max(input: Tensor, reduction_indices: Tensor, keep_dims: Boolean = false, name: String = "Max") = run {
  buildOpTensor("Max", name) {
    addInput(input, false)
    addInput(reduction_indices, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.maximum(x: Tensor, y: Tensor, name: String = "Maximum") = run {
  buildOpTensor("Maximum", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.mean(input: Tensor, reduction_indices: Tensor, keep_dims: Boolean = false, name: String = "Mean") = run {
  buildOpTensor("Mean", name) {
    addInput(input, false)
    addInput(reduction_indices, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.min(input: Tensor, reduction_indices: Tensor, keep_dims: Boolean = false, name: String = "Min") = run {
  buildOpTensor("Min", name) {
    addInput(input, false)
    addInput(reduction_indices, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.minimum(x: Tensor, y: Tensor, name: String = "Minimum") = run {
  buildOpTensor("Minimum", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.mod(x: Tensor, y: Tensor, name: String = "Mod") = run {
  buildOpTensor("Mod", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.mul(x: Tensor, y: Tensor, name: String = "Mul") = run {
  buildOpTensor("Mul", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.neg(x: Tensor, name: String = "Neg") = run {
  buildOpTensor("Neg", name) {
    addInput(x, false)
  }
}

fun TF.notEqual(x: Tensor, y: Tensor, name: String = "NotEqual") = run {
  buildOpTensor("NotEqual", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.polygamma(a: Tensor, x: Tensor, name: String = "Polygamma") = run {
  buildOpTensor("Polygamma", name) {
    addInput(a, false)
    addInput(x, false)
  }
}

fun TF.pow(x: Tensor, y: Tensor, name: String = "Pow") = run {
  buildOpTensor("Pow", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.prod(input: Tensor, reduction_indices: Tensor, keep_dims: Boolean = false, name: String = "Prod") = run {
  buildOpTensor("Prod", name) {
    addInput(input, false)
    addInput(reduction_indices, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.quantizeDownAndShrinkRange(input: Tensor, input_min: Tensor, input_max: Tensor, out_type: Int, name: String = "QuantizeDownAndShrinkRange") = run {
  buildOpTensors("QuantizeDownAndShrinkRange", name) {
    addInput(input, false)
    addInput(input_min, false)
    addInput(input_max, false)
    attrType("out_type", out_type)
  }
}

fun TF.quantizedAdd(x: Tensor, y: Tensor, min_x: Tensor, max_x: Tensor, min_y: Tensor, max_y: Tensor, toutput: Int = DT_QINT32, name: String = "QuantizedAdd") = run {
  buildOpTensors("QuantizedAdd", name) {
    addInput(x, false)
    addInput(y, false)
    addInput(min_x, false)
    addInput(max_x, false)
    addInput(min_y, false)
    addInput(max_y, false)
    attrType("Toutput", toutput)
  }
}

fun TF.quantizedMatMul(a: Tensor, b: Tensor, min_a: Tensor, max_a: Tensor, min_b: Tensor, max_b: Tensor, toutput: Int = DT_QINT32, transpose_a: Boolean = false, transpose_b: Boolean = false, tactivation: Int = DT_QUINT8, name: String = "QuantizedMatMul") = run {
  buildOpTensors("QuantizedMatMul", name) {
    addInput(a, false)
    addInput(b, false)
    addInput(min_a, false)
    addInput(max_a, false)
    addInput(min_b, false)
    addInput(max_b, false)
    attrType("Toutput", toutput)
    attr("transpose_a", transpose_a)
    attr("transpose_b", transpose_b)
    attrType("Tactivation", tactivation)
  }
}

fun TF.quantizedMul(x: Tensor, y: Tensor, min_x: Tensor, max_x: Tensor, min_y: Tensor, max_y: Tensor, toutput: Int = DT_QINT32, name: String = "QuantizedMul") = run {
  buildOpTensors("QuantizedMul", name) {
    addInput(x, false)
    addInput(y, false)
    addInput(min_x, false)
    addInput(max_x, false)
    addInput(min_y, false)
    addInput(max_y, false)
    attrType("Toutput", toutput)
  }
}

fun TF.range(start: Tensor, limit: Tensor, delta: Tensor, name: String = "Range") = run {
  buildOpTensor("Range", name) {
    addInput(start, false)
    addInput(limit, false)
    addInput(delta, false)
  }
}

fun TF.real(input: Tensor, tout: Int = DT_FLOAT, name: String = "Real") = run {
  buildOpTensor("Real", name) {
    addInput(input, false)
    attrType("Tout", tout)
  }
}

fun TF.realDiv(x: Tensor, y: Tensor, name: String = "RealDiv") = run {
  buildOpTensor("RealDiv", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.reciprocal(x: Tensor, name: String = "Reciprocal") = run {
  buildOpTensor("Reciprocal", name) {
    addInput(x, false)
  }
}

fun TF.requantizationRange(input: Tensor, input_min: Tensor, input_max: Tensor, name: String = "RequantizationRange") = run {
  buildOpTensors("RequantizationRange", name) {
    addInput(input, false)
    addInput(input_min, false)
    addInput(input_max, false)
  }
}

fun TF.requantize(input: Tensor, input_min: Tensor, input_max: Tensor, requested_output_min: Tensor, requested_output_max: Tensor, out_type: Int, name: String = "Requantize") = run {
  buildOpTensors("Requantize", name) {
    addInput(input, false)
    addInput(input_min, false)
    addInput(input_max, false)
    addInput(requested_output_min, false)
    addInput(requested_output_max, false)
    attrType("out_type", out_type)
  }
}

fun TF.rint(x: Tensor, name: String = "Rint") = run {
  buildOpTensor("Rint", name) {
    addInput(x, false)
  }
}

fun TF.round(x: Tensor, name: String = "Round") = run {
  buildOpTensor("Round", name) {
    addInput(x, false)
  }
}

fun TF.rsqrt(x: Tensor, name: String = "Rsqrt") = run {
  buildOpTensor("Rsqrt", name) {
    addInput(x, false)
  }
}

fun TF.segmentMax(data: Tensor, segment_ids: Tensor, name: String = "SegmentMax") = run {
  buildOpTensor("SegmentMax", name) {
    addInput(data, false)
    addInput(segment_ids, false)
  }
}

fun TF.segmentMean(data: Tensor, segment_ids: Tensor, name: String = "SegmentMean") = run {
  buildOpTensor("SegmentMean", name) {
    addInput(data, false)
    addInput(segment_ids, false)
  }
}

fun TF.segmentMin(data: Tensor, segment_ids: Tensor, name: String = "SegmentMin") = run {
  buildOpTensor("SegmentMin", name) {
    addInput(data, false)
    addInput(segment_ids, false)
  }
}

fun TF.segmentProd(data: Tensor, segment_ids: Tensor, name: String = "SegmentProd") = run {
  buildOpTensor("SegmentProd", name) {
    addInput(data, false)
    addInput(segment_ids, false)
  }
}

fun TF.segmentSum(data: Tensor, segment_ids: Tensor, name: String = "SegmentSum") = run {
  buildOpTensor("SegmentSum", name) {
    addInput(data, false)
    addInput(segment_ids, false)
  }
}

fun TF.select(condition: Tensor, t: Tensor, e: Tensor, name: String = "Select") = run {
  buildOpTensor("Select", name) {
    addInput(condition, false)
    addInput(t, false)
    addInput(e, false)
  }
}

fun TF.sigmoid(x: Tensor, name: String = "Sigmoid") = run {
  buildOpTensor("Sigmoid", name) {
    addInput(x, false)
  }
}

fun TF.sign(x: Tensor, name: String = "Sign") = run {
  buildOpTensor("Sign", name) {
    addInput(x, false)
  }
}

fun TF.sin(x: Tensor, name: String = "Sin") = run {
  buildOpTensor("Sin", name) {
    addInput(x, false)
  }
}

fun TF.sinh(x: Tensor, name: String = "Sinh") = run {
  buildOpTensor("Sinh", name) {
    addInput(x, false)
  }
}

fun TF.sparseMatMul(a: Tensor, b: Tensor, transpose_a: Boolean = false, transpose_b: Boolean = false, a_is_sparse: Boolean = false, b_is_sparse: Boolean = false, name: String = "SparseMatMul") = run {
  buildOpTensor("SparseMatMul", name) {
    addInput(a, false)
    addInput(b, false)
    attr("transpose_a", transpose_a)
    attr("transpose_b", transpose_b)
    attr("a_is_sparse", a_is_sparse)
    attr("b_is_sparse", b_is_sparse)
  }
}

fun TF.sparseSegmentMean(data: Tensor, indices: Tensor, segment_ids: Tensor, name: String = "SparseSegmentMean") = run {
  buildOpTensor("SparseSegmentMean", name) {
    addInput(data, false)
    addInput(indices, false)
    addInput(segment_ids, false)
  }
}

fun TF.sparseSegmentMeanGrad(grad: Tensor, indices: Tensor, segment_ids: Tensor, output_dim0: Tensor, name: String = "SparseSegmentMeanGrad") = run {
  buildOpTensor("SparseSegmentMeanGrad", name) {
    addInput(grad, false)
    addInput(indices, false)
    addInput(segment_ids, false)
    addInput(output_dim0, false)
  }
}

fun TF.sparseSegmentMeanWithNumSegments(data: Tensor, indices: Tensor, segment_ids: Tensor, num_segments: Tensor, name: String = "SparseSegmentMeanWithNumSegments") = run {
  buildOpTensor("SparseSegmentMeanWithNumSegments", name) {
    addInput(data, false)
    addInput(indices, false)
    addInput(segment_ids, false)
    addInput(num_segments, false)
  }
}

fun TF.sparseSegmentSqrtN(data: Tensor, indices: Tensor, segment_ids: Tensor, name: String = "SparseSegmentSqrtN") = run {
  buildOpTensor("SparseSegmentSqrtN", name) {
    addInput(data, false)
    addInput(indices, false)
    addInput(segment_ids, false)
  }
}

fun TF.sparseSegmentSqrtNGrad(grad: Tensor, indices: Tensor, segment_ids: Tensor, output_dim0: Tensor, name: String = "SparseSegmentSqrtNGrad") = run {
  buildOpTensor("SparseSegmentSqrtNGrad", name) {
    addInput(grad, false)
    addInput(indices, false)
    addInput(segment_ids, false)
    addInput(output_dim0, false)
  }
}

fun TF.sparseSegmentSqrtNWithNumSegments(data: Tensor, indices: Tensor, segment_ids: Tensor, num_segments: Tensor, name: String = "SparseSegmentSqrtNWithNumSegments") = run {
  buildOpTensor("SparseSegmentSqrtNWithNumSegments", name) {
    addInput(data, false)
    addInput(indices, false)
    addInput(segment_ids, false)
    addInput(num_segments, false)
  }
}

fun TF.sparseSegmentSum(data: Tensor, indices: Tensor, segment_ids: Tensor, name: String = "SparseSegmentSum") = run {
  buildOpTensor("SparseSegmentSum", name) {
    addInput(data, false)
    addInput(indices, false)
    addInput(segment_ids, false)
  }
}

fun TF.sparseSegmentSumWithNumSegments(data: Tensor, indices: Tensor, segment_ids: Tensor, num_segments: Tensor, name: String = "SparseSegmentSumWithNumSegments") = run {
  buildOpTensor("SparseSegmentSumWithNumSegments", name) {
    addInput(data, false)
    addInput(indices, false)
    addInput(segment_ids, false)
    addInput(num_segments, false)
  }
}

fun TF.sqrt(x: Tensor, name: String = "Sqrt") = run {
  buildOpTensor("Sqrt", name) {
    addInput(x, false)
  }
}

fun TF.square(x: Tensor, name: String = "Square") = run {
  buildOpTensor("Square", name) {
    addInput(x, false)
  }
}

fun TF.squaredDifference(x: Tensor, y: Tensor, name: String = "SquaredDifference") = run {
  buildOpTensor("SquaredDifference", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.sub(x: Tensor, y: Tensor, name: String = "Sub") = run {
  buildOpTensor("Sub", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.sum(input: Tensor, reduction_indices: Tensor, keep_dims: Boolean = false, name: String = "Sum") = run {
  buildOpTensor("Sum", name) {
    addInput(input, false)
    addInput(reduction_indices, false)
    attr("keep_dims", keep_dims)
  }
}

fun TF.tan(x: Tensor, name: String = "Tan") = run {
  buildOpTensor("Tan", name) {
    addInput(x, false)
  }
}

fun TF.tanh(x: Tensor, name: String = "Tanh") = run {
  buildOpTensor("Tanh", name) {
    addInput(x, false)
  }
}

fun TF.truncateDiv(x: Tensor, y: Tensor, name: String = "TruncateDiv") = run {
  buildOpTensor("TruncateDiv", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.truncateMod(x: Tensor, y: Tensor, name: String = "TruncateMod") = run {
  buildOpTensor("TruncateMod", name) {
    addInput(x, false)
    addInput(y, false)
  }
}

fun TF.unsortedSegmentMax(data: Tensor, segment_ids: Tensor, num_segments: Tensor, name: String = "UnsortedSegmentMax") = run {
  buildOpTensor("UnsortedSegmentMax", name) {
    addInput(data, false)
    addInput(segment_ids, false)
    addInput(num_segments, false)
  }
}

fun TF.unsortedSegmentMin(data: Tensor, segment_ids: Tensor, num_segments: Tensor, name: String = "UnsortedSegmentMin") = run {
  buildOpTensor("UnsortedSegmentMin", name) {
    addInput(data, false)
    addInput(segment_ids, false)
    addInput(num_segments, false)
  }
}

fun TF.unsortedSegmentProd(data: Tensor, segment_ids: Tensor, num_segments: Tensor, name: String = "UnsortedSegmentProd") = run {
  buildOpTensor("UnsortedSegmentProd", name) {
    addInput(data, false)
    addInput(segment_ids, false)
    addInput(num_segments, false)
  }
}

fun TF.unsortedSegmentSum(data: Tensor, segment_ids: Tensor, num_segments: Tensor, name: String = "UnsortedSegmentSum") = run {
  buildOpTensor("UnsortedSegmentSum", name) {
    addInput(data, false)
    addInput(segment_ids, false)
    addInput(num_segments, false)
  }
}

fun TF.zeta(x: Tensor, q: Tensor, name: String = "Zeta") = run {
  buildOpTensor("Zeta", name) {
    addInput(x, false)
    addInput(q, false)
  }
}

fun TF.igammaGradA(a: Tensor, x: Tensor, name: String = "IgammaGradA") = run {
  buildOpTensor("IgammaGradA", name) {
    addInput(a, false)
    addInput(x, false)
  }
}

fun TF.invGrad(y: Tensor, dy: Tensor, name: String = "InvGrad") = run {
  buildOpTensor("InvGrad", name) {
    addInput(y, false)
    addInput(dy, false)
  }
}

fun TF.reciprocalGrad(y: Tensor, dy: Tensor, name: String = "ReciprocalGrad") = run {
  buildOpTensor("ReciprocalGrad", name) {
    addInput(y, false)
    addInput(dy, false)
  }
}

fun TF.rsqrtGrad(y: Tensor, dy: Tensor, name: String = "RsqrtGrad") = run {
  buildOpTensor("RsqrtGrad", name) {
    addInput(y, false)
    addInput(dy, false)
  }
}

fun TF.sigmoidGrad(y: Tensor, dy: Tensor, name: String = "SigmoidGrad") = run {
  buildOpTensor("SigmoidGrad", name) {
    addInput(y, false)
    addInput(dy, false)
  }
}

fun TF.sqrtGrad(y: Tensor, dy: Tensor, name: String = "SqrtGrad") = run {
  buildOpTensor("SqrtGrad", name) {
    addInput(y, false)
    addInput(dy, false)
  }
}

fun TF.tanhGrad(y: Tensor, dy: Tensor, name: String = "TanhGrad") = run {
  buildOpTensor("TanhGrad", name) {
    addInput(y, false)
    addInput(dy, false)
  }
}
